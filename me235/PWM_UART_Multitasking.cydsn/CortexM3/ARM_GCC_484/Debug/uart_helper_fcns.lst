ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"uart_helper_fcns.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.bss
  19              		.align	2
  20              	transmit_buffer:
  21 0000 00000000 		.space	128
  21      00000000 
  21      00000000 
  21      00000000 
  21      00000000 
  22              		.align	2
  23              	receive_buffer:
  24 0080 00000000 		.space	128
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              	num_chars_received:
  26 0100 00       		.space	1
  27 0101 00       		.align	1
  28              	data:
  29 0102 0000     		.space	2
  30              	mode:
  31 0104 00       		.space	1
  32 0105 000000   		.section	.rodata
  33              		.align	2
  34              	.LC0:
  35 0000 0D0A5374 		.ascii	"\015\012Stopping PWM.\015\012\000"
  35      6F707069 
  35      6E672050 
  35      574D2E0D 
  35      0A00
  36 0012 0000     		.align	2
  37              	.LC1:
  38 0014 0D0A5265 		.ascii	"\015\012Restarting PWM.\015\012\000"
  38      73746172 
  38      74696E67 
  38      2050574D 
  38      2E0D0A00 
  39              		.section	.text.Interrupt_Handler_UART_Receive,"ax",%progbits
  40              		.align	2
  41              		.global	Interrupt_Handler_UART_Receive
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 2


  42              		.thumb
  43              		.thumb_func
  44              		.type	Interrupt_Handler_UART_Receive, %function
  45              	Interrupt_Handler_UART_Receive:
  46              	.LFB56:
  47              		.file 1 ".\\uart_helper_fcns.c"
   1:.\uart_helper_fcns.c **** /* ========================================
   2:.\uart_helper_fcns.c ****  *
   3:.\uart_helper_fcns.c ****  * Copyright Andrew P. Sabelhaus, 2018 
   4:.\uart_helper_fcns.c ****  * See README and LICENSE for more details.
   5:.\uart_helper_fcns.c ****  *
   6:.\uart_helper_fcns.c ****  * ========================================
   7:.\uart_helper_fcns.c **** */
   8:.\uart_helper_fcns.c **** 
   9:.\uart_helper_fcns.c **** // Code adapted heavily from Cypress' example CE95277 ADC and UART,
  10:.\uart_helper_fcns.c **** // but all re-written by Drew.
  11:.\uart_helper_fcns.c **** 
  12:.\uart_helper_fcns.c **** // We wrote the declarations in the header file,
  13:.\uart_helper_fcns.c **** // and define them here.
  14:.\uart_helper_fcns.c **** // Including this header file in both main.c and here will allow the functions
  15:.\uart_helper_fcns.c **** // to be accessible both places (one to define them, one to use them).
  16:.\uart_helper_fcns.c **** 
  17:.\uart_helper_fcns.c **** // Unlike in the header files, we don't need to add include guards here.
  18:.\uart_helper_fcns.c **** // That's because the guards are already present in the .h files themselves.
  19:.\uart_helper_fcns.c **** #include "uart_helper_fcns.h"
  20:.\uart_helper_fcns.c **** #include <project.h>
  21:.\uart_helper_fcns.c **** // stdio.h provides the sprintf and sscanf functions for working with strings.
  22:.\uart_helper_fcns.c **** #include "stdio.h"
  23:.\uart_helper_fcns.c **** 
  24:.\uart_helper_fcns.c **** // We're going to define the size of the character array for the transmission
  25:.\uart_helper_fcns.c **** // back to the PC. This is in bytes: if a uint8 is one character, we can store
  26:.\uart_helper_fcns.c **** // a string of this length. E.g. 16 gives us 16 characters, including any integers represented as c
  27:.\uart_helper_fcns.c **** // This solves exactly the same problem as in the supplement to tutorial 6!!!
  28:.\uart_helper_fcns.c **** // Drew used 128 here, like with receive, because it's 
  29:.\uart_helper_fcns.c **** // "big enough." Compare to the size of the data of the PWM, as returned from Readdata(), 
  30:.\uart_helper_fcns.c **** // and the string of text I put down below.
  31:.\uart_helper_fcns.c **** // How many bytes (characters) will we expect to need to send back? How many are "taken up" by the 
  32:.\uart_helper_fcns.c **** #define TRANSMIT_LENGTH 128
  33:.\uart_helper_fcns.c **** // We're also going to keep a buffer of received characters, since multiple bytes are needed.
  34:.\uart_helper_fcns.c **** // The size of this here is the number of characters you can type into TeraTerm before pressing ent
  35:.\uart_helper_fcns.c **** // George suggested 128, which is way many more than you'll need. 
  36:.\uart_helper_fcns.c **** // Note the example of "make the array larger than you need just in case because it doesn't really 
  37:.\uart_helper_fcns.c **** #define RECEIVE_LENGTH 128
  38:.\uart_helper_fcns.c **** 
  39:.\uart_helper_fcns.c **** // See tutorial 7 supplement for discussion on "static".
  40:.\uart_helper_fcns.c **** 
  41:.\uart_helper_fcns.c **** // Also, keep the buffer as a global variable instead of creating it inside the ISR.
  42:.\uart_helper_fcns.c **** // This is for efficiency, and since we'll need to send back a string of characters with numbers al
  43:.\uart_helper_fcns.c **** static char transmit_buffer[TRANSMIT_LENGTH];
  44:.\uart_helper_fcns.c **** // similarly, we want a receive buffer, for taking in multiple charactes as they are sent to the PS
  45:.\uart_helper_fcns.c **** static char receive_buffer[RECEIVE_LENGTH];
  46:.\uart_helper_fcns.c **** 
  47:.\uart_helper_fcns.c **** // Since the UART only sends single bytes, we encounter a problem with setting numerical values.
  48:.\uart_helper_fcns.c **** // Specifically, the byte send is interpreted as a character, NOT a number.
  49:.\uart_helper_fcns.c **** // See the ASCII table for a bit more intuition: for example, to set a data between 100 and 200, we
  50:.\uart_helper_fcns.c **** // type in the characters between 'd' and 'weird L bar thing that isn't on Drew's keyboard. 
  51:.\uart_helper_fcns.c **** // https://www.asciitable.com/
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 3


  52:.\uart_helper_fcns.c **** // That's not OK. Instead, let's take in each character, store it in a buffer.
  53:.\uart_helper_fcns.c **** // The num_chars_received integer allows us to index into the string buffer (since it's an array of
  54:.\uart_helper_fcns.c **** static uint8 num_chars_received = 0;
  55:.\uart_helper_fcns.c **** 
  56:.\uart_helper_fcns.c **** // In the example that Drew got from George, we used a character to split
  57:.\uart_helper_fcns.c **** 
  58:.\uart_helper_fcns.c **** // the data, as recorded in the helpers below. By declaring with global scope, we
  59:.\uart_helper_fcns.c **** // increase efficiency.
  60:.\uart_helper_fcns.c **** static uint16 data = 0;
  61:.\uart_helper_fcns.c **** 
  62:.\uart_helper_fcns.c **** // We're also going to let people adjust the duty cycle (compare value).
  63:.\uart_helper_fcns.c **** // So, we need to store a character representing the mode.
  64:.\uart_helper_fcns.c **** static char mode;
  65:.\uart_helper_fcns.c **** 
  66:.\uart_helper_fcns.c **** // Definition of the UART ISR
  67:.\uart_helper_fcns.c **** // We use the same line for the function definition, with the CY_ISR macro.
  68:.\uart_helper_fcns.c **** // Compare this to tutorial 6, with "pythagorean"
  69:.\uart_helper_fcns.c **** CY_ISR( Interrupt_Handler_UART_Receive){
  48              		.loc 1 69 0
  49              		.cfi_startproc
  50              		@ args = 0, pretend = 0, frame = 8
  51              		@ frame_needed = 1, uses_anonymous_args = 0
  52 0000 80B5     		push	{r7, lr}
  53              		.cfi_def_cfa_offset 8
  54              		.cfi_offset 7, -8
  55              		.cfi_offset 14, -4
  56 0002 82B0     		sub	sp, sp, #8
  57              		.cfi_def_cfa_offset 16
  58 0004 00AF     		add	r7, sp, #0
  59              		.cfi_def_cfa_register 7
  70:.\uart_helper_fcns.c ****     // We assume this ISR is called when a byte is received.
  71:.\uart_helper_fcns.c ****     // See how the IDE doesn't give any errors, as long as we include project.h here.
  72:.\uart_helper_fcns.c ****     uint8 received_byte = UART_for_USB_GetChar();
  60              		.loc 1 72 0
  61 0006 FFF7FEFF 		bl	UART_for_USB_GetChar
  62 000a 0346     		mov	r3, r0
  63 000c FB71     		strb	r3, [r7, #7]
  73:.\uart_helper_fcns.c ****     
  74:.\uart_helper_fcns.c ****     // In order for this to be clear, let's repeat the character back to the terminal.
  75:.\uart_helper_fcns.c ****     // This way, it 'looks like' we're typing into the terminal!
  76:.\uart_helper_fcns.c ****     UART_for_USB_PutChar( received_byte );
  64              		.loc 1 76 0
  65 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  66 0010 1846     		mov	r0, r3
  67 0012 FFF7FEFF 		bl	UART_for_USB_PutChar
  77:.\uart_helper_fcns.c ****     
  78:.\uart_helper_fcns.c ****     //DEBUGGING
  79:.\uart_helper_fcns.c ****     /*
  80:.\uart_helper_fcns.c ****     UART_for_USB_PutString( "Received a character: ");
  81:.\uart_helper_fcns.c ****     UART_for_USB_PutChar( received_byte );
  82:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
  83:.\uart_helper_fcns.c ****     */
  84:.\uart_helper_fcns.c ****     
  85:.\uart_helper_fcns.c ****     // Next, we need to deal with what was received, in the following way.
  86:.\uart_helper_fcns.c ****     // If a new line is received (the \n character, or ASCII values 10 or 12 or 13 depending on if 
  87:.\uart_helper_fcns.c ****     // then finally set the data.
  88:.\uart_helper_fcns.c ****     // Otherwise, add to the uint16 we're keeping track of.
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 4


  89:.\uart_helper_fcns.c ****     // Luckily enough, C allows us to "switch" on uint8s, since characters are also numbers via the
  90:.\uart_helper_fcns.c ****     switch( received_byte )
  68              		.loc 1 90 0
  69 0016 FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  70 0018 0D2B     		cmp	r3, #13
  71 001a 09D0     		beq	.L3
  72 001c 0D2B     		cmp	r3, #13
  73 001e 02DC     		bgt	.L4
  74 0020 0A2B     		cmp	r3, #10
  75 0022 05D0     		beq	.L3
  76 0024 1EE0     		b	.L2
  77              	.L4:
  78 0026 652B     		cmp	r3, #101
  79 0028 13D0     		beq	.L5
  80 002a 782B     		cmp	r3, #120
  81 002c 08D0     		beq	.L6
  82 002e 19E0     		b	.L2
  83              	.L3:
  91:.\uart_helper_fcns.c ****     {
  92:.\uart_helper_fcns.c ****         // Students: look up switch-case statements. to understand this more.
  93:.\uart_helper_fcns.c ****         // We're going to take advantage of the "flow" of switch-case to do the same thing for char
  94:.\uart_helper_fcns.c ****         // which could all be newlines, by not "break"-ing until the end of the third case.
  95:.\uart_helper_fcns.c ****         case '\r':
  96:.\uart_helper_fcns.c ****             // flow downward, no specific code for carriage return
  97:.\uart_helper_fcns.c ****         case '\n':
  98:.\uart_helper_fcns.c ****             // This code will run if the received byte is either a carriage return or a newline.
  99:.\uart_helper_fcns.c ****             // Since the PSoC received a new line...
 100:.\uart_helper_fcns.c ****             // First, terminate the string. This is for the use of sscanf below.
 101:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = '\0';
  84              		.loc 1 101 0
  85 0030 144B     		ldr	r3, .L8
  86 0032 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  87 0034 144A     		ldr	r2, .L8+4
  88 0036 0021     		movs	r1, #0
  89 0038 D154     		strb	r1, [r2, r3]
 102:.\uart_helper_fcns.c ****             Write_PWM_and_UART();
  90              		.loc 1 102 0
  91 003a FFF7FEFF 		bl	Write_PWM_and_UART
 103:.\uart_helper_fcns.c ****             // This helper will also reset the data we're tracking, and the num chars received.
 104:.\uart_helper_fcns.c ****             // By "break"-ing, the next case is not executed.
 105:.\uart_helper_fcns.c ****             break;
  92              		.loc 1 105 0
  93 003e 1DE0     		b	.L1
  94              	.L6:
 106:.\uart_helper_fcns.c ****         case 'x':
 107:.\uart_helper_fcns.c ****             // Added functionality: if the user types an x, then the PWM stops.
 108:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\nStopping PWM.\r\n");
  95              		.loc 1 108 0
  96 0040 1248     		ldr	r0, .L8+8
  97 0042 FFF7FEFF 		bl	UART_for_USB_PutString
 109:.\uart_helper_fcns.c ****             PWM_Servo_Stop();
  98              		.loc 1 109 0
  99 0046 FFF7FEFF 		bl	PWM_Servo_Stop
 110:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
 111:.\uart_helper_fcns.c ****             num_chars_received = 0;
 100              		.loc 1 111 0
 101 004a 0E4B     		ldr	r3, .L8
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 5


 102 004c 0022     		movs	r2, #0
 103 004e 1A70     		strb	r2, [r3]
 112:.\uart_helper_fcns.c ****             break;
 104              		.loc 1 112 0
 105 0050 14E0     		b	.L1
 106              	.L5:
 113:.\uart_helper_fcns.c ****         case 'e':
 114:.\uart_helper_fcns.c ****             // Similarly, type e to enable.
 115:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\nRestarting PWM.\r\n");
 107              		.loc 1 115 0
 108 0052 0F48     		ldr	r0, .L8+12
 109 0054 FFF7FEFF 		bl	UART_for_USB_PutString
 116:.\uart_helper_fcns.c ****             PWM_Servo_Start();
 110              		.loc 1 116 0
 111 0058 FFF7FEFF 		bl	PWM_Servo_Start
 117:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
 118:.\uart_helper_fcns.c ****             num_chars_received = 0;
 112              		.loc 1 118 0
 113 005c 094B     		ldr	r3, .L8
 114 005e 0022     		movs	r2, #0
 115 0060 1A70     		strb	r2, [r3]
 119:.\uart_helper_fcns.c ****             break;
 116              		.loc 1 119 0
 117 0062 0BE0     		b	.L1
 118              	.L2:
 120:.\uart_helper_fcns.c ****         default:
 121:.\uart_helper_fcns.c ****             // The "default" case is "anything else", which is "store another character."
 122:.\uart_helper_fcns.c ****             // Add to the received buffer.
 123:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = received_byte;
 119              		.loc 1 123 0
 120 0064 074B     		ldr	r3, .L8
 121 0066 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 122 0068 074A     		ldr	r2, .L8+4
 123 006a F979     		ldrb	r1, [r7, #7]
 124 006c D154     		strb	r1, [r2, r3]
 124:.\uart_helper_fcns.c ****             // We need to increment the counter. i++ does this without an equals sign for assignmen
 125:.\uart_helper_fcns.c ****             num_chars_received++;
 125              		.loc 1 125 0
 126 006e 054B     		ldr	r3, .L8
 127 0070 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 128 0072 0133     		adds	r3, r3, #1
 129 0074 DAB2     		uxtb	r2, r3
 130 0076 034B     		ldr	r3, .L8
 131 0078 1A70     		strb	r2, [r3]
 126:.\uart_helper_fcns.c ****             break;
 132              		.loc 1 126 0
 133 007a 00BF     		nop
 134              	.L1:
 127:.\uart_helper_fcns.c ****         // end of case statement.
 128:.\uart_helper_fcns.c ****     }
 129:.\uart_helper_fcns.c ****     
 130:.\uart_helper_fcns.c ****     // We're going to assume that the character we receive is an integer, 
 131:.\uart_helper_fcns.c ****     // representing the data.
 132:.\uart_helper_fcns.c ****     // For a transmission of 8 bits, we can only set the data between 0 and 255.
 133:.\uart_helper_fcns.c ****     // This is OK for how we've configured the PWM for our servo: 
 134:.\uart_helper_fcns.c ****     // our data can only be between 100 and 200 anyway (1 ms for min angle, 2 ms for max angle).
 135:.\uart_helper_fcns.c ****     // To get better resolution here, you'll need to do a handful of things:
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 6


 136:.\uart_helper_fcns.c ****     // (1) change the clock of the PWM so that we'll need a uint16 to represent 1 ms to 2 ms of "on
 137:.\uart_helper_fcns.c ****     // (2) receive two bytes (as uint8) from the UART, keep track of the first one
 138:.\uart_helper_fcns.c ****     // (3) once two are received, combine them into a uint16
 139:.\uart_helper_fcns.c ****     // (4) write the uint16 to the PWM's data, as with the code below.    
 140:.\uart_helper_fcns.c ****     
 141:.\uart_helper_fcns.c ****     
 142:.\uart_helper_fcns.c ****     
 143:.\uart_helper_fcns.c **** }
 135              		.loc 1 143 0
 136 007c 0837     		adds	r7, r7, #8
 137 007e BD46     		mov	sp, r7
 138              		@ sp needed
 139 0080 80BD     		pop	{r7, pc}
 140              	.L9:
 141 0082 00BF     		.align	2
 142              	.L8:
 143 0084 00010000 		.word	num_chars_received
 144 0088 80000000 		.word	receive_buffer
 145 008c 00000000 		.word	.LC0
 146 0090 14000000 		.word	.LC1
 147              		.cfi_endproc
 148              	.LFE56:
 149              		.size	Interrupt_Handler_UART_Receive, .-Interrupt_Handler_UART_Receive
 150              		.section	.rodata
 151              		.align	2
 152              	.LC2:
 153 0028 2563203A 		.ascii	"%c : %hu\000"
 153      20256875 
 153      00
 154 0031 000000   		.align	2
 155              	.LC3:
 156 0034 4572726F 		.ascii	"Error! incorrect data. Did you type a number after "
 156      72212069 
 156      6E636F72 
 156      72656374 
 156      20646174 
 157 0067 61202870 		.ascii	"a (p or d), a colon, and the spaces between?\015\012"
 157      206F7220 
 157      64292C20 
 157      6120636F 
 157      6C6F6E2C 
 158 0095 00       		.ascii	"\000"
 159 0096 0000     		.align	2
 160              	.LC4:
 161 0098 52656365 		.ascii	"Received the string: \000"
 161      69766564 
 161      20746865 
 161      20737472 
 161      696E673A 
 162 00ae 0000     		.align	2
 163              	.LC5:
 164 00b0 0D0A00   		.ascii	"\015\012\000"
 165 00b3 00       		.align	2
 166              	.LC6:
 167 00b4 50574D20 		.ascii	"PWM now has a period of: %i \015\012\000"
 167      6E6F7720 
 167      68617320 
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 7


 167      61207065 
 167      72696F64 
 168 00d3 00       		.align	2
 169              	.LC7:
 170 00d4 50574D20 		.ascii	"PWM now has a duty cycle (in clock ticks) of: %i \015"
 170      6E6F7720 
 170      68617320 
 170      61206475 
 170      74792063 
 171 0106 0A00     		.ascii	"\012\000"
 172              		.align	2
 173              	.LC8:
 174 0108 4572726F 		.ascii	"Error! You didn't type a p or d. \015\012\000"
 174      72212059 
 174      6F752064 
 174      69646E27 
 174      74207479 
 175              		.section	.text.Write_PWM_and_UART,"ax",%progbits
 176              		.align	2
 177              		.global	Write_PWM_and_UART
 178              		.thumb
 179              		.thumb_func
 180              		.type	Write_PWM_and_UART, %function
 181              	Write_PWM_and_UART:
 182              	.LFB57:
 144:.\uart_helper_fcns.c **** 
 145:.\uart_helper_fcns.c **** // Helper function that does the writing to the PWM and UART.
 146:.\uart_helper_fcns.c **** // makes the ISR code easier to understand.
 147:.\uart_helper_fcns.c **** void Write_PWM_and_UART(){
 183              		.loc 1 147 0
 184              		.cfi_startproc
 185              		@ args = 0, pretend = 0, frame = 8
 186              		@ frame_needed = 1, uses_anonymous_args = 0
 187 0000 B0B5     		push	{r4, r5, r7, lr}
 188              		.cfi_def_cfa_offset 16
 189              		.cfi_offset 4, -16
 190              		.cfi_offset 5, -12
 191              		.cfi_offset 7, -8
 192              		.cfi_offset 14, -4
 193 0002 82B0     		sub	sp, sp, #8
 194              		.cfi_def_cfa_offset 24
 195 0004 00AF     		add	r7, sp, #0
 196              		.cfi_def_cfa_register 7
 148:.\uart_helper_fcns.c ****     // OK, so now, we have a string in the receive buffer of the form "(p/d):somenumber".
 149:.\uart_helper_fcns.c ****     // Get the mode:
 150:.\uart_helper_fcns.c ****     //sscanf( receive_buffer, "%c:", &mode);
 151:.\uart_helper_fcns.c ****     //DEBUGGING
 152:.\uart_helper_fcns.c ****     //UART_for_USB_PutChar(mode);
 153:.\uart_helper_fcns.c ****     
 154:.\uart_helper_fcns.c ****     // Read in the integer after the p:
 155:.\uart_helper_fcns.c ****     // The %hu specifier is for unsigned shorts (16 bit integers)
 156:.\uart_helper_fcns.c ****     // Let's receive back the number of integers returned from sscanf
 157:.\uart_helper_fcns.c ****     int num_var_filled;
 158:.\uart_helper_fcns.c ****     num_var_filled = sscanf( receive_buffer, "%c : %hu", &mode, &data);
 197              		.loc 1 158 0
 198 0006 2E48     		ldr	r0, .L17
 199 0008 2E49     		ldr	r1, .L17+4
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 8


 200 000a 2F4A     		ldr	r2, .L17+8
 201 000c 2F4B     		ldr	r3, .L17+12
 202 000e FFF7FEFF 		bl	sscanf
 203 0012 7860     		str	r0, [r7, #4]
 159:.\uart_helper_fcns.c ****     // Need to check: was anything received? Equivalently, did sscanf find exactly one uint16?
 160:.\uart_helper_fcns.c ****     if( num_var_filled != 2){
 204              		.loc 1 160 0
 205 0014 7B68     		ldr	r3, [r7, #4]
 206 0016 022B     		cmp	r3, #2
 207 0018 05D0     		beq	.L11
 161:.\uart_helper_fcns.c ****         UART_for_USB_PutString("Error! incorrect data. Did you type a number after a (p or d), a co
 208              		.loc 1 161 0
 209 001a 2D48     		ldr	r0, .L17+16
 210 001c FFF7FEFF 		bl	UART_for_USB_PutString
 162:.\uart_helper_fcns.c ****         data = 0;
 211              		.loc 1 162 0
 212 0020 2A4B     		ldr	r3, .L17+12
 213 0022 0022     		movs	r2, #0
 214 0024 1A80     		strh	r2, [r3]	@ movhi
 215              	.L11:
 163:.\uart_helper_fcns.c ****     }
 164:.\uart_helper_fcns.c ****     // DEBUGGING
 165:.\uart_helper_fcns.c ****     UART_for_USB_PutString("Received the string: ");
 216              		.loc 1 165 0
 217 0026 2B48     		ldr	r0, .L17+20
 218 0028 FFF7FEFF 		bl	UART_for_USB_PutString
 166:.\uart_helper_fcns.c ****     UART_for_USB_PutString( receive_buffer );
 219              		.loc 1 166 0
 220 002c 2448     		ldr	r0, .L17
 221 002e FFF7FEFF 		bl	UART_for_USB_PutString
 167:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
 222              		.loc 1 167 0
 223 0032 2948     		ldr	r0, .L17+24
 224 0034 FFF7FEFF 		bl	UART_for_USB_PutString
 168:.\uart_helper_fcns.c ****     
 169:.\uart_helper_fcns.c ****     // Depending on the mode, write either the data or the duty cycle:
 170:.\uart_helper_fcns.c ****     switch( mode )
 225              		.loc 1 170 0
 226 0038 234B     		ldr	r3, .L17+8
 227 003a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 228 003c 642B     		cmp	r3, #100
 229 003e 11D0     		beq	.L13
 230 0040 702B     		cmp	r3, #112
 231 0042 1FD1     		bne	.L16
 232              	.LBB2:
 171:.\uart_helper_fcns.c ****     {
 172:.\uart_helper_fcns.c ****         case 'p':
 173:.\uart_helper_fcns.c ****             // Now, set the data, 
 174:.\uart_helper_fcns.c ****             PWM_Servo_WritePeriod( data );
 233              		.loc 1 174 0
 234 0044 214B     		ldr	r3, .L17+12
 235 0046 1B88     		ldrh	r3, [r3]
 236 0048 1846     		mov	r0, r3
 237 004a FFF7FEFF 		bl	PWM_Servo_WritePeriod
 175:.\uart_helper_fcns.c ****             // and send back the data that was just written, for confirmation.
 176:.\uart_helper_fcns.c ****             // In C, to concatenate a number (integer) and a string (characters), you need to...
 177:.\uart_helper_fcns.c ****             // (1) store the result, as confirmed by the PWM component.
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 9


 178:.\uart_helper_fcns.c ****             uint16 period_written = PWM_Servo_ReadPeriod();
 238              		.loc 1 178 0
 239 004e FFF7FEFF 		bl	PWM_Servo_ReadPeriod
 240 0052 0346     		mov	r3, r0
 241 0054 7B80     		strh	r3, [r7, #2]	@ movhi
 179:.\uart_helper_fcns.c ****             // (2) Concatenate this data with a string of characters describing what we did
 180:.\uart_helper_fcns.c ****             // Requires stdio.h (standard input/output) for the sprintf function.
 181:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "PWM now has a period of: %i \r\n", period_written);
 242              		.loc 1 181 0
 243 0056 7B88     		ldrh	r3, [r7, #2]
 244 0058 2048     		ldr	r0, .L17+28
 245 005a 2149     		ldr	r1, .L17+32
 246 005c 1A46     		mov	r2, r3
 247 005e FFF7FEFF 		bl	sprintf
 182:.\uart_helper_fcns.c ****             break;
 248              		.loc 1 182 0
 249 0062 1DE0     		b	.L15
 250              	.L13:
 183:.\uart_helper_fcns.c ****         case 'd':
 184:.\uart_helper_fcns.c ****             // Instead, set the compare value, the duty cycle in clock ticks.
 185:.\uart_helper_fcns.c ****             PWM_Servo_WriteCompare( data );
 251              		.loc 1 185 0
 252 0064 194B     		ldr	r3, .L17+12
 253 0066 1B88     		ldrh	r3, [r3]
 254 0068 1846     		mov	r0, r3
 255 006a FFF7FEFF 		bl	PWM_Servo_WriteCompare
 186:.\uart_helper_fcns.c ****             // Like with the period:
 187:.\uart_helper_fcns.c ****             uint16 duty_written = PWM_Servo_ReadCompare();
 256              		.loc 1 187 0
 257 006e FFF7FEFF 		bl	PWM_Servo_ReadCompare
 258 0072 0346     		mov	r3, r0
 259 0074 3B80     		strh	r3, [r7]	@ movhi
 188:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "PWM now has a duty cycle (in clock ticks) of: %i \r\n", duty
 260              		.loc 1 188 0
 261 0076 3B88     		ldrh	r3, [r7]
 262 0078 1848     		ldr	r0, .L17+28
 263 007a 1A49     		ldr	r1, .L17+36
 264 007c 1A46     		mov	r2, r3
 265 007e FFF7FEFF 		bl	sprintf
 189:.\uart_helper_fcns.c ****             break;
 266              		.loc 1 189 0
 267 0082 0DE0     		b	.L15
 268              	.L16:
 190:.\uart_helper_fcns.c ****         default:
 191:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "Error! You didn't type a p or d. \r\n");
 269              		.loc 1 191 0
 270 0084 154A     		ldr	r2, .L17+28
 271 0086 184B     		ldr	r3, .L17+40
 272 0088 1446     		mov	r4, r2
 273 008a 1D46     		mov	r5, r3
 274 008c 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 275 008e 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 276 0090 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 277 0092 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 278 0094 2B68     		ldr	r3, [r5]
 279 0096 2360     		str	r3, [r4]
 192:.\uart_helper_fcns.c ****             mode = 0;
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 10


 280              		.loc 1 192 0
 281 0098 0B4B     		ldr	r3, .L17+8
 282 009a 0022     		movs	r2, #0
 283 009c 1A70     		strb	r2, [r3]
 193:.\uart_helper_fcns.c ****             break;
 284              		.loc 1 193 0
 285 009e 00BF     		nop
 286              	.L15:
 287              	.LBE2:
 194:.\uart_helper_fcns.c ****     }
 195:.\uart_helper_fcns.c ****     
 196:.\uart_helper_fcns.c ****     // sscanf requires the address-of (&) for the variable to be written.
 197:.\uart_helper_fcns.c ****     
 198:.\uart_helper_fcns.c ****     
 199:.\uart_helper_fcns.c ****     // (3) send the byte back to your PC
 200:.\uart_helper_fcns.c ****     UART_for_USB_PutString( transmit_buffer );    
 288              		.loc 1 200 0
 289 00a0 0E48     		ldr	r0, .L17+28
 290 00a2 FFF7FEFF 		bl	UART_for_USB_PutString
 201:.\uart_helper_fcns.c ****     // to make this easier to read, send another newline.
 202:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
 291              		.loc 1 202 0
 292 00a6 0C48     		ldr	r0, .L17+24
 293 00a8 FFF7FEFF 		bl	UART_for_USB_PutString
 203:.\uart_helper_fcns.c ****     // (4) Send another little string prompting the next input.
 204:.\uart_helper_fcns.c ****     //UART_for_USB_PutString( " by typing p: then a new data, between 100 and 200 (min and max data
 205:.\uart_helper_fcns.c ****     // Reset the indexing into the array
 206:.\uart_helper_fcns.c ****     num_chars_received = 0;
 294              		.loc 1 206 0
 295 00ac 0F4B     		ldr	r3, .L17+44
 296 00ae 0022     		movs	r2, #0
 297 00b0 1A70     		strb	r2, [r3]
 207:.\uart_helper_fcns.c ****     // and just in case let's do the data too.
 208:.\uart_helper_fcns.c ****     data = 0;
 298              		.loc 1 208 0
 299 00b2 064B     		ldr	r3, .L17+12
 300 00b4 0022     		movs	r2, #0
 301 00b6 1A80     		strh	r2, [r3]	@ movhi
 209:.\uart_helper_fcns.c ****     // Note that we don't have to reset the buffer here, since sscanf only reads up until the first
 210:.\uart_helper_fcns.c **** }
 302              		.loc 1 210 0
 303 00b8 0837     		adds	r7, r7, #8
 304 00ba BD46     		mov	sp, r7
 305              		@ sp needed
 306 00bc B0BD     		pop	{r4, r5, r7, pc}
 307              	.L18:
 308 00be 00BF     		.align	2
 309              	.L17:
 310 00c0 80000000 		.word	receive_buffer
 311 00c4 28000000 		.word	.LC2
 312 00c8 04010000 		.word	mode
 313 00cc 02010000 		.word	data
 314 00d0 34000000 		.word	.LC3
 315 00d4 98000000 		.word	.LC4
 316 00d8 B0000000 		.word	.LC5
 317 00dc 00000000 		.word	transmit_buffer
 318 00e0 B4000000 		.word	.LC6
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 11


 319 00e4 D4000000 		.word	.LC7
 320 00e8 08010000 		.word	.LC8
 321 00ec 00010000 		.word	num_chars_received
 322              		.cfi_endproc
 323              	.LFE57:
 324              		.size	Write_PWM_and_UART, .-Write_PWM_and_UART
 325              		.text
 326              	.Letext0:
 327              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
 328              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
 329              		.file 4 ".\\Generated_Source\\PSoC5/cytypes.h"
 330              		.file 5 ".\\Generated_Source\\PSoC5/core_cm3.h"
 331              		.section	.debug_info,"",%progbits
 332              	.Ldebug_info0:
 333 0000 94010000 		.4byte	0x194
 334 0004 0400     		.2byte	0x4
 335 0006 00000000 		.4byte	.Ldebug_abbrev0
 336 000a 04       		.byte	0x4
 337 000b 01       		.uleb128 0x1
 338 000c 65000000 		.4byte	.LASF26
 339 0010 01       		.byte	0x1
 340 0011 1F020000 		.4byte	.LASF27
 341 0015 E1000000 		.4byte	.LASF28
 342 0019 00000000 		.4byte	.Ldebug_ranges0+0
 343 001d 00000000 		.4byte	0
 344 0021 00000000 		.4byte	.Ldebug_line0
 345 0025 02       		.uleb128 0x2
 346 0026 01       		.byte	0x1
 347 0027 06       		.byte	0x6
 348 0028 2B000000 		.4byte	.LASF0
 349 002c 02       		.uleb128 0x2
 350 002d 01       		.byte	0x1
 351 002e 08       		.byte	0x8
 352 002f 44000000 		.4byte	.LASF1
 353 0033 02       		.uleb128 0x2
 354 0034 02       		.byte	0x2
 355 0035 05       		.byte	0x5
 356 0036 06020000 		.4byte	.LASF2
 357 003a 02       		.uleb128 0x2
 358 003b 02       		.byte	0x2
 359 003c 07       		.byte	0x7
 360 003d 22010000 		.4byte	.LASF3
 361 0041 03       		.uleb128 0x3
 362 0042 00000000 		.4byte	.LASF9
 363 0046 02       		.byte	0x2
 364 0047 37       		.byte	0x37
 365 0048 4C000000 		.4byte	0x4c
 366 004c 02       		.uleb128 0x2
 367 004d 04       		.byte	0x4
 368 004e 05       		.byte	0x5
 369 004f 16020000 		.4byte	.LASF4
 370 0053 02       		.uleb128 0x2
 371 0054 04       		.byte	0x4
 372 0055 07       		.byte	0x7
 373 0056 83010000 		.4byte	.LASF5
 374 005a 02       		.uleb128 0x2
 375 005b 08       		.byte	0x8
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 12


 376 005c 05       		.byte	0x5
 377 005d F3010000 		.4byte	.LASF6
 378 0061 02       		.uleb128 0x2
 379 0062 08       		.byte	0x8
 380 0063 07       		.byte	0x7
 381 0064 A9010000 		.4byte	.LASF7
 382 0068 04       		.uleb128 0x4
 383 0069 04       		.byte	0x4
 384 006a 05       		.byte	0x5
 385 006b 696E7400 		.ascii	"int\000"
 386 006f 02       		.uleb128 0x2
 387 0070 04       		.byte	0x4
 388 0071 07       		.byte	0x7
 389 0072 9C010000 		.4byte	.LASF8
 390 0076 03       		.uleb128 0x3
 391 0077 E2010000 		.4byte	.LASF10
 392 007b 03       		.byte	0x3
 393 007c 41       		.byte	0x41
 394 007d 41000000 		.4byte	0x41
 395 0081 03       		.uleb128 0x3
 396 0082 10020000 		.4byte	.LASF11
 397 0086 04       		.byte	0x4
 398 0087 A1       		.byte	0xa1
 399 0088 2C000000 		.4byte	0x2c
 400 008c 03       		.uleb128 0x3
 401 008d 95010000 		.4byte	.LASF12
 402 0091 04       		.byte	0x4
 403 0092 A2       		.byte	0xa2
 404 0093 3A000000 		.4byte	0x3a
 405 0097 02       		.uleb128 0x2
 406 0098 04       		.byte	0x4
 407 0099 04       		.byte	0x4
 408 009a 20000000 		.4byte	.LASF13
 409 009e 02       		.uleb128 0x2
 410 009f 08       		.byte	0x8
 411 00a0 04       		.byte	0x4
 412 00a1 19000000 		.4byte	.LASF14
 413 00a5 02       		.uleb128 0x2
 414 00a6 01       		.byte	0x1
 415 00a7 08       		.byte	0x8
 416 00a8 01020000 		.4byte	.LASF15
 417 00ac 02       		.uleb128 0x2
 418 00ad 04       		.byte	0x4
 419 00ae 07       		.byte	0x7
 420 00af EA010000 		.4byte	.LASF16
 421 00b3 05       		.uleb128 0x5
 422 00b4 51010000 		.4byte	.LASF29
 423 00b8 01       		.byte	0x1
 424 00b9 45       		.byte	0x45
 425 00ba 00000000 		.4byte	.LFB56
 426 00be 94000000 		.4byte	.LFE56-.LFB56
 427 00c2 01       		.uleb128 0x1
 428 00c3 9C       		.byte	0x9c
 429 00c4 D7000000 		.4byte	0xd7
 430 00c8 06       		.uleb128 0x6
 431 00c9 D4010000 		.4byte	.LASF17
 432 00cd 01       		.byte	0x1
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 13


 433 00ce 48       		.byte	0x48
 434 00cf 81000000 		.4byte	0x81
 435 00d3 02       		.uleb128 0x2
 436 00d4 91       		.byte	0x91
 437 00d5 77       		.sleb128 -9
 438 00d6 00       		.byte	0
 439 00d7 07       		.uleb128 0x7
 440 00d8 52000000 		.4byte	.LASF30
 441 00dc 01       		.byte	0x1
 442 00dd 93       		.byte	0x93
 443 00de 00000000 		.4byte	.LFB57
 444 00e2 F0000000 		.4byte	.LFE57-.LFB57
 445 00e6 01       		.uleb128 0x1
 446 00e7 9C       		.byte	0x9c
 447 00e8 21010000 		.4byte	0x121
 448 00ec 06       		.uleb128 0x6
 449 00ed C5010000 		.4byte	.LASF18
 450 00f1 01       		.byte	0x1
 451 00f2 9D       		.byte	0x9d
 452 00f3 68000000 		.4byte	0x68
 453 00f7 02       		.uleb128 0x2
 454 00f8 91       		.byte	0x91
 455 00f9 6C       		.sleb128 -20
 456 00fa 08       		.uleb128 0x8
 457 00fb 44000000 		.4byte	.LBB2
 458 00ff 5C000000 		.4byte	.LBE2-.LBB2
 459 0103 06       		.uleb128 0x6
 460 0104 0A000000 		.4byte	.LASF19
 461 0108 01       		.byte	0x1
 462 0109 B2       		.byte	0xb2
 463 010a 8C000000 		.4byte	0x8c
 464 010e 02       		.uleb128 0x2
 465 010f 91       		.byte	0x91
 466 0110 6A       		.sleb128 -22
 467 0111 06       		.uleb128 0x6
 468 0112 37000000 		.4byte	.LASF20
 469 0116 01       		.byte	0x1
 470 0117 BB       		.byte	0xbb
 471 0118 8C000000 		.4byte	0x8c
 472 011c 02       		.uleb128 0x2
 473 011d 91       		.byte	0x91
 474 011e 68       		.sleb128 -24
 475 011f 00       		.byte	0
 476 0120 00       		.byte	0
 477 0121 09       		.uleb128 0x9
 478 0122 A5000000 		.4byte	0xa5
 479 0126 31010000 		.4byte	0x131
 480 012a 0A       		.uleb128 0xa
 481 012b AC000000 		.4byte	0xac
 482 012f 7F       		.byte	0x7f
 483 0130 00       		.byte	0
 484 0131 06       		.uleb128 0x6
 485 0132 34020000 		.4byte	.LASF21
 486 0136 01       		.byte	0x1
 487 0137 2B       		.byte	0x2b
 488 0138 21010000 		.4byte	0x121
 489 013c 05       		.uleb128 0x5
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 14


 490 013d 03       		.byte	0x3
 491 013e 00000000 		.4byte	transmit_buffer
 492 0142 06       		.uleb128 0x6
 493 0143 35010000 		.4byte	.LASF22
 494 0147 01       		.byte	0x1
 495 0148 2D       		.byte	0x2d
 496 0149 21010000 		.4byte	0x121
 497 014d 05       		.uleb128 0x5
 498 014e 03       		.byte	0x3
 499 014f 80000000 		.4byte	receive_buffer
 500 0153 06       		.uleb128 0x6
 501 0154 70010000 		.4byte	.LASF23
 502 0158 01       		.byte	0x1
 503 0159 36       		.byte	0x36
 504 015a 81000000 		.4byte	0x81
 505 015e 05       		.uleb128 0x5
 506 015f 03       		.byte	0x3
 507 0160 00010000 		.4byte	num_chars_received
 508 0164 06       		.uleb128 0x6
 509 0165 26000000 		.4byte	.LASF24
 510 0169 01       		.byte	0x1
 511 016a 3C       		.byte	0x3c
 512 016b 8C000000 		.4byte	0x8c
 513 016f 05       		.uleb128 0x5
 514 0170 03       		.byte	0x3
 515 0171 02010000 		.4byte	data
 516 0175 06       		.uleb128 0x6
 517 0176 C0010000 		.4byte	.LASF25
 518 017a 01       		.byte	0x1
 519 017b 40       		.byte	0x40
 520 017c A5000000 		.4byte	0xa5
 521 0180 05       		.uleb128 0x5
 522 0181 03       		.byte	0x3
 523 0182 04010000 		.4byte	mode
 524 0186 0B       		.uleb128 0xb
 525 0187 44010000 		.4byte	.LASF31
 526 018b 05       		.byte	0x5
 527 018c 1606     		.2byte	0x616
 528 018e 92010000 		.4byte	0x192
 529 0192 0C       		.uleb128 0xc
 530 0193 76000000 		.4byte	0x76
 531 0197 00       		.byte	0
 532              		.section	.debug_abbrev,"",%progbits
 533              	.Ldebug_abbrev0:
 534 0000 01       		.uleb128 0x1
 535 0001 11       		.uleb128 0x11
 536 0002 01       		.byte	0x1
 537 0003 25       		.uleb128 0x25
 538 0004 0E       		.uleb128 0xe
 539 0005 13       		.uleb128 0x13
 540 0006 0B       		.uleb128 0xb
 541 0007 03       		.uleb128 0x3
 542 0008 0E       		.uleb128 0xe
 543 0009 1B       		.uleb128 0x1b
 544 000a 0E       		.uleb128 0xe
 545 000b 55       		.uleb128 0x55
 546 000c 17       		.uleb128 0x17
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 15


 547 000d 11       		.uleb128 0x11
 548 000e 01       		.uleb128 0x1
 549 000f 10       		.uleb128 0x10
 550 0010 17       		.uleb128 0x17
 551 0011 00       		.byte	0
 552 0012 00       		.byte	0
 553 0013 02       		.uleb128 0x2
 554 0014 24       		.uleb128 0x24
 555 0015 00       		.byte	0
 556 0016 0B       		.uleb128 0xb
 557 0017 0B       		.uleb128 0xb
 558 0018 3E       		.uleb128 0x3e
 559 0019 0B       		.uleb128 0xb
 560 001a 03       		.uleb128 0x3
 561 001b 0E       		.uleb128 0xe
 562 001c 00       		.byte	0
 563 001d 00       		.byte	0
 564 001e 03       		.uleb128 0x3
 565 001f 16       		.uleb128 0x16
 566 0020 00       		.byte	0
 567 0021 03       		.uleb128 0x3
 568 0022 0E       		.uleb128 0xe
 569 0023 3A       		.uleb128 0x3a
 570 0024 0B       		.uleb128 0xb
 571 0025 3B       		.uleb128 0x3b
 572 0026 0B       		.uleb128 0xb
 573 0027 49       		.uleb128 0x49
 574 0028 13       		.uleb128 0x13
 575 0029 00       		.byte	0
 576 002a 00       		.byte	0
 577 002b 04       		.uleb128 0x4
 578 002c 24       		.uleb128 0x24
 579 002d 00       		.byte	0
 580 002e 0B       		.uleb128 0xb
 581 002f 0B       		.uleb128 0xb
 582 0030 3E       		.uleb128 0x3e
 583 0031 0B       		.uleb128 0xb
 584 0032 03       		.uleb128 0x3
 585 0033 08       		.uleb128 0x8
 586 0034 00       		.byte	0
 587 0035 00       		.byte	0
 588 0036 05       		.uleb128 0x5
 589 0037 2E       		.uleb128 0x2e
 590 0038 01       		.byte	0x1
 591 0039 3F       		.uleb128 0x3f
 592 003a 19       		.uleb128 0x19
 593 003b 03       		.uleb128 0x3
 594 003c 0E       		.uleb128 0xe
 595 003d 3A       		.uleb128 0x3a
 596 003e 0B       		.uleb128 0xb
 597 003f 3B       		.uleb128 0x3b
 598 0040 0B       		.uleb128 0xb
 599 0041 27       		.uleb128 0x27
 600 0042 19       		.uleb128 0x19
 601 0043 11       		.uleb128 0x11
 602 0044 01       		.uleb128 0x1
 603 0045 12       		.uleb128 0x12
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 16


 604 0046 06       		.uleb128 0x6
 605 0047 40       		.uleb128 0x40
 606 0048 18       		.uleb128 0x18
 607 0049 9642     		.uleb128 0x2116
 608 004b 19       		.uleb128 0x19
 609 004c 01       		.uleb128 0x1
 610 004d 13       		.uleb128 0x13
 611 004e 00       		.byte	0
 612 004f 00       		.byte	0
 613 0050 06       		.uleb128 0x6
 614 0051 34       		.uleb128 0x34
 615 0052 00       		.byte	0
 616 0053 03       		.uleb128 0x3
 617 0054 0E       		.uleb128 0xe
 618 0055 3A       		.uleb128 0x3a
 619 0056 0B       		.uleb128 0xb
 620 0057 3B       		.uleb128 0x3b
 621 0058 0B       		.uleb128 0xb
 622 0059 49       		.uleb128 0x49
 623 005a 13       		.uleb128 0x13
 624 005b 02       		.uleb128 0x2
 625 005c 18       		.uleb128 0x18
 626 005d 00       		.byte	0
 627 005e 00       		.byte	0
 628 005f 07       		.uleb128 0x7
 629 0060 2E       		.uleb128 0x2e
 630 0061 01       		.byte	0x1
 631 0062 3F       		.uleb128 0x3f
 632 0063 19       		.uleb128 0x19
 633 0064 03       		.uleb128 0x3
 634 0065 0E       		.uleb128 0xe
 635 0066 3A       		.uleb128 0x3a
 636 0067 0B       		.uleb128 0xb
 637 0068 3B       		.uleb128 0x3b
 638 0069 0B       		.uleb128 0xb
 639 006a 11       		.uleb128 0x11
 640 006b 01       		.uleb128 0x1
 641 006c 12       		.uleb128 0x12
 642 006d 06       		.uleb128 0x6
 643 006e 40       		.uleb128 0x40
 644 006f 18       		.uleb128 0x18
 645 0070 9642     		.uleb128 0x2116
 646 0072 19       		.uleb128 0x19
 647 0073 01       		.uleb128 0x1
 648 0074 13       		.uleb128 0x13
 649 0075 00       		.byte	0
 650 0076 00       		.byte	0
 651 0077 08       		.uleb128 0x8
 652 0078 0B       		.uleb128 0xb
 653 0079 01       		.byte	0x1
 654 007a 11       		.uleb128 0x11
 655 007b 01       		.uleb128 0x1
 656 007c 12       		.uleb128 0x12
 657 007d 06       		.uleb128 0x6
 658 007e 00       		.byte	0
 659 007f 00       		.byte	0
 660 0080 09       		.uleb128 0x9
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 17


 661 0081 01       		.uleb128 0x1
 662 0082 01       		.byte	0x1
 663 0083 49       		.uleb128 0x49
 664 0084 13       		.uleb128 0x13
 665 0085 01       		.uleb128 0x1
 666 0086 13       		.uleb128 0x13
 667 0087 00       		.byte	0
 668 0088 00       		.byte	0
 669 0089 0A       		.uleb128 0xa
 670 008a 21       		.uleb128 0x21
 671 008b 00       		.byte	0
 672 008c 49       		.uleb128 0x49
 673 008d 13       		.uleb128 0x13
 674 008e 2F       		.uleb128 0x2f
 675 008f 0B       		.uleb128 0xb
 676 0090 00       		.byte	0
 677 0091 00       		.byte	0
 678 0092 0B       		.uleb128 0xb
 679 0093 34       		.uleb128 0x34
 680 0094 00       		.byte	0
 681 0095 03       		.uleb128 0x3
 682 0096 0E       		.uleb128 0xe
 683 0097 3A       		.uleb128 0x3a
 684 0098 0B       		.uleb128 0xb
 685 0099 3B       		.uleb128 0x3b
 686 009a 05       		.uleb128 0x5
 687 009b 49       		.uleb128 0x49
 688 009c 13       		.uleb128 0x13
 689 009d 3F       		.uleb128 0x3f
 690 009e 19       		.uleb128 0x19
 691 009f 3C       		.uleb128 0x3c
 692 00a0 19       		.uleb128 0x19
 693 00a1 00       		.byte	0
 694 00a2 00       		.byte	0
 695 00a3 0C       		.uleb128 0xc
 696 00a4 35       		.uleb128 0x35
 697 00a5 00       		.byte	0
 698 00a6 49       		.uleb128 0x49
 699 00a7 13       		.uleb128 0x13
 700 00a8 00       		.byte	0
 701 00a9 00       		.byte	0
 702 00aa 00       		.byte	0
 703              		.section	.debug_aranges,"",%progbits
 704 0000 24000000 		.4byte	0x24
 705 0004 0200     		.2byte	0x2
 706 0006 00000000 		.4byte	.Ldebug_info0
 707 000a 04       		.byte	0x4
 708 000b 00       		.byte	0
 709 000c 0000     		.2byte	0
 710 000e 0000     		.2byte	0
 711 0010 00000000 		.4byte	.LFB56
 712 0014 94000000 		.4byte	.LFE56-.LFB56
 713 0018 00000000 		.4byte	.LFB57
 714 001c F0000000 		.4byte	.LFE57-.LFB57
 715 0020 00000000 		.4byte	0
 716 0024 00000000 		.4byte	0
 717              		.section	.debug_ranges,"",%progbits
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 18


 718              	.Ldebug_ranges0:
 719 0000 00000000 		.4byte	.LFB56
 720 0004 94000000 		.4byte	.LFE56
 721 0008 00000000 		.4byte	.LFB57
 722 000c F0000000 		.4byte	.LFE57
 723 0010 00000000 		.4byte	0
 724 0014 00000000 		.4byte	0
 725              		.section	.debug_line,"",%progbits
 726              	.Ldebug_line0:
 727 0000 B5010000 		.section	.debug_str,"MS",%progbits,1
 727      02005D01 
 727      00000201 
 727      FB0E0D00 
 727      01010101 
 728              	.LASF9:
 729 0000 5F5F696E 		.ascii	"__int32_t\000"
 729      7433325F 
 729      7400
 730              	.LASF19:
 731 000a 70657269 		.ascii	"period_written\000"
 731      6F645F77 
 731      72697474 
 731      656E00
 732              	.LASF14:
 733 0019 646F7562 		.ascii	"double\000"
 733      6C6500
 734              	.LASF13:
 735 0020 666C6F61 		.ascii	"float\000"
 735      7400
 736              	.LASF24:
 737 0026 64617461 		.ascii	"data\000"
 737      00
 738              	.LASF0:
 739 002b 7369676E 		.ascii	"signed char\000"
 739      65642063 
 739      68617200 
 740              	.LASF20:
 741 0037 64757479 		.ascii	"duty_written\000"
 741      5F777269 
 741      7474656E 
 741      00
 742              	.LASF1:
 743 0044 756E7369 		.ascii	"unsigned char\000"
 743      676E6564 
 743      20636861 
 743      7200
 744              	.LASF30:
 745 0052 57726974 		.ascii	"Write_PWM_and_UART\000"
 745      655F5057 
 745      4D5F616E 
 745      645F5541 
 745      525400
 746              	.LASF26:
 747 0065 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 747      4320342E 
 747      382E3420 
 747      32303134 
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 19


 747      30353236 
 748 0098 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m3 -mthumb -g -O"
 748      20726576 
 748      6973696F 
 748      6E203231 
 748      31333538 
 749 00cb 30202D66 		.ascii	"0 -ffunction-sections\000"
 749      66756E63 
 749      74696F6E 
 749      2D736563 
 749      74696F6E 
 750              	.LASF28:
 751 00e1 443A5C57 		.ascii	"D:\\WindowsGitHub\\psoc-examples\\me235\\PWM_UART_M"
 751      696E646F 
 751      77734769 
 751      74487562 
 751      5C70736F 
 752 0110 756C7469 		.ascii	"ultitasking.cydsn\000"
 752      7461736B 
 752      696E672E 
 752      63796473 
 752      6E00
 753              	.LASF3:
 754 0122 73686F72 		.ascii	"short unsigned int\000"
 754      7420756E 
 754      7369676E 
 754      65642069 
 754      6E7400
 755              	.LASF22:
 756 0135 72656365 		.ascii	"receive_buffer\000"
 756      6976655F 
 756      62756666 
 756      657200
 757              	.LASF31:
 758 0144 49544D5F 		.ascii	"ITM_RxBuffer\000"
 758      52784275 
 758      66666572 
 758      00
 759              	.LASF29:
 760 0151 496E7465 		.ascii	"Interrupt_Handler_UART_Receive\000"
 760      72727570 
 760      745F4861 
 760      6E646C65 
 760      725F5541 
 761              	.LASF23:
 762 0170 6E756D5F 		.ascii	"num_chars_received\000"
 762      63686172 
 762      735F7265 
 762      63656976 
 762      656400
 763              	.LASF5:
 764 0183 6C6F6E67 		.ascii	"long unsigned int\000"
 764      20756E73 
 764      69676E65 
 764      6420696E 
 764      7400
 765              	.LASF12:
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 20


 766 0195 75696E74 		.ascii	"uint16\000"
 766      313600
 767              	.LASF8:
 768 019c 756E7369 		.ascii	"unsigned int\000"
 768      676E6564 
 768      20696E74 
 768      00
 769              	.LASF7:
 770 01a9 6C6F6E67 		.ascii	"long long unsigned int\000"
 770      206C6F6E 
 770      6720756E 
 770      7369676E 
 770      65642069 
 771              	.LASF25:
 772 01c0 6D6F6465 		.ascii	"mode\000"
 772      00
 773              	.LASF18:
 774 01c5 6E756D5F 		.ascii	"num_var_filled\000"
 774      7661725F 
 774      66696C6C 
 774      656400
 775              	.LASF17:
 776 01d4 72656365 		.ascii	"received_byte\000"
 776      69766564 
 776      5F627974 
 776      6500
 777              	.LASF10:
 778 01e2 696E7433 		.ascii	"int32_t\000"
 778      325F7400 
 779              	.LASF16:
 780 01ea 73697A65 		.ascii	"sizetype\000"
 780      74797065 
 780      00
 781              	.LASF6:
 782 01f3 6C6F6E67 		.ascii	"long long int\000"
 782      206C6F6E 
 782      6720696E 
 782      7400
 783              	.LASF15:
 784 0201 63686172 		.ascii	"char\000"
 784      00
 785              	.LASF2:
 786 0206 73686F72 		.ascii	"short int\000"
 786      7420696E 
 786      7400
 787              	.LASF11:
 788 0210 75696E74 		.ascii	"uint8\000"
 788      3800
 789              	.LASF4:
 790 0216 6C6F6E67 		.ascii	"long int\000"
 790      20696E74 
 790      00
 791              	.LASF27:
 792 021f 2E5C7561 		.ascii	".\\uart_helper_fcns.c\000"
 792      72745F68 
 792      656C7065 
 792      725F6663 
ARM GAS  C:\Users\andre\AppData\Local\Temp\cc4IagEi.s 			page 21


 792      6E732E63 
 793              	.LASF21:
 794 0234 7472616E 		.ascii	"transmit_buffer\000"
 794      736D6974 
 794      5F627566 
 794      66657200 
 795              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
