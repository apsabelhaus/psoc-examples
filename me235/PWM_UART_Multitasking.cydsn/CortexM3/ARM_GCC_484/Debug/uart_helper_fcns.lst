ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"uart_helper_fcns.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.bss
  19              		.align	2
  20              	transmit_buffer:
  21 0000 00000000 		.space	128
  21      00000000 
  21      00000000 
  21      00000000 
  21      00000000 
  22              		.align	2
  23              	receive_buffer:
  24 0080 00000000 		.space	128
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              	num_chars_received:
  26 0100 00       		.space	1
  27 0101 00       		.align	1
  28              	data:
  29 0102 0000     		.space	2
  30              	mode:
  31 0104 00       		.space	1
  32 0105 000000   		.section	.rodata
  33              		.align	2
  34              	.LC0:
  35 0000 0D0A00   		.ascii	"\015\012\000"
  36 0003 00       		.align	2
  37              	.LC1:
  38 0004 0D0A5374 		.ascii	"\015\012Stopping PWM.\015\012\000"
  38      6F707069 
  38      6E672050 
  38      574D2E0D 
  38      0A00
  39 0016 0000     		.align	2
  40              	.LC2:
  41 0018 0D0A5265 		.ascii	"\015\012Restarting PWM.\015\012\000"
  41      73746172 
  41      74696E67 
  41      2050574D 
  41      2E0D0A00 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 2


  42              		.section	.text.Interrupt_Handler_UART_Receive,"ax",%progbits
  43              		.align	2
  44              		.global	Interrupt_Handler_UART_Receive
  45              		.thumb
  46              		.thumb_func
  47              		.type	Interrupt_Handler_UART_Receive, %function
  48              	Interrupt_Handler_UART_Receive:
  49              	.LFB56:
  50              		.file 1 ".\\uart_helper_fcns.c"
   1:.\uart_helper_fcns.c **** /* ========================================
   2:.\uart_helper_fcns.c ****  *
   3:.\uart_helper_fcns.c ****  * Copyright Andrew P. Sabelhaus, 2018 
   4:.\uart_helper_fcns.c ****  * See README and LICENSE for more details.
   5:.\uart_helper_fcns.c ****  *
   6:.\uart_helper_fcns.c ****  * ========================================
   7:.\uart_helper_fcns.c **** */
   8:.\uart_helper_fcns.c **** 
   9:.\uart_helper_fcns.c **** // Code adapted heavily from Cypress' example CE95277 ADC and UART,
  10:.\uart_helper_fcns.c **** // but all re-written by Drew.
  11:.\uart_helper_fcns.c **** 
  12:.\uart_helper_fcns.c **** // We wrote the declarations in the header file,
  13:.\uart_helper_fcns.c **** // and define them here.
  14:.\uart_helper_fcns.c **** // Including this header file in both main.c and here will allow the functions
  15:.\uart_helper_fcns.c **** // to be accessible both places (one to define them, one to use them).
  16:.\uart_helper_fcns.c **** 
  17:.\uart_helper_fcns.c **** // Unlike in the header files, we don't need to add include guards here.
  18:.\uart_helper_fcns.c **** // That's because the guards are already present in the .h files themselves.
  19:.\uart_helper_fcns.c **** #include "uart_helper_fcns.h"
  20:.\uart_helper_fcns.c **** #include <project.h>
  21:.\uart_helper_fcns.c **** // stdio.h provides the sprintf and sscanf functions for working with strings.
  22:.\uart_helper_fcns.c **** #include "stdio.h"
  23:.\uart_helper_fcns.c **** 
  24:.\uart_helper_fcns.c **** // We're going to define the size of the character array for the transmission
  25:.\uart_helper_fcns.c **** // back to the PC. This is in bytes: if a uint8 is one character, we can store
  26:.\uart_helper_fcns.c **** // a string of this length. E.g. 16 gives us 16 characters, including any integers represented as c
  27:.\uart_helper_fcns.c **** // This solves exactly the same problem as in the supplement to tutorial 6!!!
  28:.\uart_helper_fcns.c **** // Drew used 128 here, like with receive, because it's 
  29:.\uart_helper_fcns.c **** // "big enough." Compare to the size of the data of the PWM, as returned from Readdata(), 
  30:.\uart_helper_fcns.c **** // and the string of text I put down below.
  31:.\uart_helper_fcns.c **** // How many bytes (characters) will we expect to need to send back? How many are "taken up" by the 
  32:.\uart_helper_fcns.c **** #define TRANSMIT_LENGTH 128
  33:.\uart_helper_fcns.c **** // We're also going to keep a buffer of received characters, since multiple bytes are needed.
  34:.\uart_helper_fcns.c **** // The size of this here is the number of characters you can type into TeraTerm before pressing ent
  35:.\uart_helper_fcns.c **** // George suggested 128, which is way many more than you'll need. 
  36:.\uart_helper_fcns.c **** // Note the example of "make the array larger than you need just in case because it doesn't really 
  37:.\uart_helper_fcns.c **** #define RECEIVE_LENGTH 128
  38:.\uart_helper_fcns.c **** 
  39:.\uart_helper_fcns.c **** // See tutorial 7 supplement for discussion on "static".
  40:.\uart_helper_fcns.c **** 
  41:.\uart_helper_fcns.c **** // Also, keep the buffer as a global variable instead of creating it inside the ISR.
  42:.\uart_helper_fcns.c **** // This is for efficiency, and since we'll need to send back a string of characters with numbers al
  43:.\uart_helper_fcns.c **** static char transmit_buffer[TRANSMIT_LENGTH];
  44:.\uart_helper_fcns.c **** // similarly, we want a receive buffer, for taking in multiple charactes as they are sent to the PS
  45:.\uart_helper_fcns.c **** static char receive_buffer[RECEIVE_LENGTH];
  46:.\uart_helper_fcns.c **** 
  47:.\uart_helper_fcns.c **** // Since the UART only sends single bytes, we encounter a problem with setting numerical values.
  48:.\uart_helper_fcns.c **** // Specifically, the byte send is interpreted as a character, NOT a number.
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 3


  49:.\uart_helper_fcns.c **** // See the ASCII table for a bit more intuition: for example, to set a data between 100 and 200, we
  50:.\uart_helper_fcns.c **** // type in the characters between 'd' and 'weird L bar thing that isn't on Drew's keyboard. 
  51:.\uart_helper_fcns.c **** // https://www.asciitable.com/
  52:.\uart_helper_fcns.c **** // That's not OK. Instead, let's take in each character, store it in a buffer.
  53:.\uart_helper_fcns.c **** // The num_chars_received integer allows us to index into the string buffer (since it's an array of
  54:.\uart_helper_fcns.c **** static uint8 num_chars_received = 0;
  55:.\uart_helper_fcns.c **** 
  56:.\uart_helper_fcns.c **** // In the example that Drew got from George, we used a character to split
  57:.\uart_helper_fcns.c **** 
  58:.\uart_helper_fcns.c **** // the data, as recorded in the helpers below. By declaring with global scope, we
  59:.\uart_helper_fcns.c **** // increase efficiency.
  60:.\uart_helper_fcns.c **** static uint16 data = 0;
  61:.\uart_helper_fcns.c **** 
  62:.\uart_helper_fcns.c **** // We're also going to let people adjust the duty cycle (compare value).
  63:.\uart_helper_fcns.c **** // So, we need to store a character representing the mode.
  64:.\uart_helper_fcns.c **** static char mode;
  65:.\uart_helper_fcns.c **** 
  66:.\uart_helper_fcns.c **** // Definition of the UART ISR
  67:.\uart_helper_fcns.c **** // We use the same line for the function definition, with the CY_ISR macro.
  68:.\uart_helper_fcns.c **** // Compare this to tutorial 6, with "pythagorean"
  69:.\uart_helper_fcns.c **** CY_ISR( Interrupt_Handler_UART_Receive){
  51              		.loc 1 69 0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 8
  54              		@ frame_needed = 1, uses_anonymous_args = 0
  55 0000 80B5     		push	{r7, lr}
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 7, -8
  58              		.cfi_offset 14, -4
  59 0002 82B0     		sub	sp, sp, #8
  60              		.cfi_def_cfa_offset 16
  61 0004 00AF     		add	r7, sp, #0
  62              		.cfi_def_cfa_register 7
  70:.\uart_helper_fcns.c ****     // We assume this ISR is called when a byte is received.
  71:.\uart_helper_fcns.c ****     // See how the IDE doesn't give any errors, as long as we include project.h here.
  72:.\uart_helper_fcns.c ****     uint8 received_byte = UART_for_USB_GetChar();
  63              		.loc 1 72 0
  64 0006 FFF7FEFF 		bl	UART_for_USB_GetChar
  65 000a 0346     		mov	r3, r0
  66 000c FB71     		strb	r3, [r7, #7]
  73:.\uart_helper_fcns.c ****     
  74:.\uart_helper_fcns.c ****     // In order for this to be clear, let's repeat the character back to the terminal.
  75:.\uart_helper_fcns.c ****     // This way, it 'looks like' we're typing into the terminal!
  76:.\uart_helper_fcns.c ****     
  77:.\uart_helper_fcns.c ****     //DEBUGGING
  78:.\uart_helper_fcns.c ****     /*
  79:.\uart_helper_fcns.c ****     UART_for_USB_PutString( "Received a character: ");
  80:.\uart_helper_fcns.c ****     UART_for_USB_PutChar( received_byte );
  81:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
  82:.\uart_helper_fcns.c ****     */
  83:.\uart_helper_fcns.c ****     
  84:.\uart_helper_fcns.c ****     // Next, we need to deal with what was received, in the following way.
  85:.\uart_helper_fcns.c ****     // If a new line is received (the \n character, or ASCII values 10 or 12 or 13 depending on if 
  86:.\uart_helper_fcns.c ****     // then finally set the data.
  87:.\uart_helper_fcns.c ****     // Otherwise, add to the uint16 we're keeping track of.
  88:.\uart_helper_fcns.c ****     // Luckily enough, C allows us to "switch" on uint8s, since characters are also numbers via the
  89:.\uart_helper_fcns.c ****     switch( received_byte )
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 4


  67              		.loc 1 89 0
  68 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  69 0010 0D2B     		cmp	r3, #13
  70 0012 09D0     		beq	.L3
  71 0014 0D2B     		cmp	r3, #13
  72 0016 02DC     		bgt	.L4
  73 0018 0A2B     		cmp	r3, #10
  74 001a 05D0     		beq	.L3
  75 001c 21E0     		b	.L2
  76              	.L4:
  77 001e 652B     		cmp	r3, #101
  78 0020 16D0     		beq	.L5
  79 0022 782B     		cmp	r3, #120
  80 0024 0BD0     		beq	.L6
  81 0026 1CE0     		b	.L2
  82              	.L3:
  90:.\uart_helper_fcns.c ****     {
  91:.\uart_helper_fcns.c ****         // Students: look up switch-case statements. to understand this more.
  92:.\uart_helper_fcns.c ****         // We're going to take advantage of the "flow" of switch-case to do the same thing for char
  93:.\uart_helper_fcns.c ****         // which could all be newlines, by not "break"-ing until the end of the third case.
  94:.\uart_helper_fcns.c ****         case '\r':
  95:.\uart_helper_fcns.c ****             // flow downward, no specific code for carriage return
  96:.\uart_helper_fcns.c ****         case '\n':
  97:.\uart_helper_fcns.c ****             // This code will run if the received byte is either a carriage return or a newline.
  98:.\uart_helper_fcns.c ****             // Since the PSoC received a new line...
  99:.\uart_helper_fcns.c ****             // First, terminate the string. This is for the use of sscanf below.
 100:.\uart_helper_fcns.c ****             // Print back the newline/carriage return, to complete the "respond back to the termina
 101:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\n");
  83              		.loc 1 101 0
  84 0028 1748     		ldr	r0, .L8
  85 002a FFF7FEFF 		bl	UART_for_USB_PutString
 102:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = '\0';
  86              		.loc 1 102 0
  87 002e 174B     		ldr	r3, .L8+4
  88 0030 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  89 0032 174A     		ldr	r2, .L8+8
  90 0034 0021     		movs	r1, #0
  91 0036 D154     		strb	r1, [r2, r3]
 103:.\uart_helper_fcns.c ****             Write_PWM_and_UART();
  92              		.loc 1 103 0
  93 0038 FFF7FEFF 		bl	Write_PWM_and_UART
 104:.\uart_helper_fcns.c ****             // This helper will also reset the data we're tracking, and the num chars received.
 105:.\uart_helper_fcns.c ****             // By "break"-ing, the next case is not executed.
 106:.\uart_helper_fcns.c ****             break;
  94              		.loc 1 106 0
  95 003c 21E0     		b	.L1
  96              	.L6:
 107:.\uart_helper_fcns.c ****         case 'x':
 108:.\uart_helper_fcns.c ****             // Added functionality: if the user types an x, then the PWM stops.
 109:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\nStopping PWM.\r\n");
  97              		.loc 1 109 0
  98 003e 1548     		ldr	r0, .L8+12
  99 0040 FFF7FEFF 		bl	UART_for_USB_PutString
 110:.\uart_helper_fcns.c ****             PWM_Servo_Stop();
 100              		.loc 1 110 0
 101 0044 FFF7FEFF 		bl	PWM_Servo_Stop
 111:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 5


 112:.\uart_helper_fcns.c ****             num_chars_received = 0;
 102              		.loc 1 112 0
 103 0048 104B     		ldr	r3, .L8+4
 104 004a 0022     		movs	r2, #0
 105 004c 1A70     		strb	r2, [r3]
 113:.\uart_helper_fcns.c ****             break;
 106              		.loc 1 113 0
 107 004e 18E0     		b	.L1
 108              	.L5:
 114:.\uart_helper_fcns.c ****         case 'e':
 115:.\uart_helper_fcns.c ****             // Similarly, type e to enable.
 116:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\nRestarting PWM.\r\n");
 109              		.loc 1 116 0
 110 0050 1148     		ldr	r0, .L8+16
 111 0052 FFF7FEFF 		bl	UART_for_USB_PutString
 117:.\uart_helper_fcns.c ****             PWM_Servo_Start();
 112              		.loc 1 117 0
 113 0056 FFF7FEFF 		bl	PWM_Servo_Start
 118:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
 119:.\uart_helper_fcns.c ****             num_chars_received = 0;
 114              		.loc 1 119 0
 115 005a 0C4B     		ldr	r3, .L8+4
 116 005c 0022     		movs	r2, #0
 117 005e 1A70     		strb	r2, [r3]
 120:.\uart_helper_fcns.c ****             break;
 118              		.loc 1 120 0
 119 0060 0FE0     		b	.L1
 120              	.L2:
 121:.\uart_helper_fcns.c ****         default:
 122:.\uart_helper_fcns.c ****             // The "default" case is "anything else", which is "store another character."
 123:.\uart_helper_fcns.c ****             // Add to the received buffer.
 124:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = received_byte;
 121              		.loc 1 124 0
 122 0062 0A4B     		ldr	r3, .L8+4
 123 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 124 0066 0A4A     		ldr	r2, .L8+8
 125 0068 F979     		ldrb	r1, [r7, #7]
 126 006a D154     		strb	r1, [r2, r3]
 125:.\uart_helper_fcns.c ****             // Respond back to the terminal
 126:.\uart_helper_fcns.c ****             UART_for_USB_PutChar( received_byte );
 127              		.loc 1 126 0
 128 006c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 129 006e 1846     		mov	r0, r3
 130 0070 FFF7FEFF 		bl	UART_for_USB_PutChar
 127:.\uart_helper_fcns.c ****             // We need to increment the counter. i++ does this without an equals sign for assignmen
 128:.\uart_helper_fcns.c ****             num_chars_received++;
 131              		.loc 1 128 0
 132 0074 054B     		ldr	r3, .L8+4
 133 0076 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 134 0078 0133     		adds	r3, r3, #1
 135 007a DAB2     		uxtb	r2, r3
 136 007c 034B     		ldr	r3, .L8+4
 137 007e 1A70     		strb	r2, [r3]
 129:.\uart_helper_fcns.c ****             break;
 138              		.loc 1 129 0
 139 0080 00BF     		nop
 140              	.L1:
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 6


 130:.\uart_helper_fcns.c ****         // end of case statement.
 131:.\uart_helper_fcns.c ****     }
 132:.\uart_helper_fcns.c ****     
 133:.\uart_helper_fcns.c ****     // We're going to assume that the character we receive is an integer, 
 134:.\uart_helper_fcns.c ****     // representing the data.
 135:.\uart_helper_fcns.c ****     // For a transmission of 8 bits, we can only set the data between 0 and 255.
 136:.\uart_helper_fcns.c ****     // This is OK for how we've configured the PWM for our servo: 
 137:.\uart_helper_fcns.c ****     // our data can only be between 100 and 200 anyway (1 ms for min angle, 2 ms for max angle).
 138:.\uart_helper_fcns.c ****     // To get better resolution here, you'll need to do a handful of things:
 139:.\uart_helper_fcns.c ****     // (1) change the clock of the PWM so that we'll need a uint16 to represent 1 ms to 2 ms of "on
 140:.\uart_helper_fcns.c ****     // (2) receive two bytes (as uint8) from the UART, keep track of the first one
 141:.\uart_helper_fcns.c ****     // (3) once two are received, combine them into a uint16
 142:.\uart_helper_fcns.c ****     // (4) write the uint16 to the PWM's data, as with the code below.    
 143:.\uart_helper_fcns.c ****     
 144:.\uart_helper_fcns.c ****     
 145:.\uart_helper_fcns.c ****     
 146:.\uart_helper_fcns.c **** }
 141              		.loc 1 146 0
 142 0082 0837     		adds	r7, r7, #8
 143 0084 BD46     		mov	sp, r7
 144              		@ sp needed
 145 0086 80BD     		pop	{r7, pc}
 146              	.L9:
 147              		.align	2
 148              	.L8:
 149 0088 00000000 		.word	.LC0
 150 008c 00010000 		.word	num_chars_received
 151 0090 80000000 		.word	receive_buffer
 152 0094 04000000 		.word	.LC1
 153 0098 18000000 		.word	.LC2
 154              		.cfi_endproc
 155              	.LFE56:
 156              		.size	Interrupt_Handler_UART_Receive, .-Interrupt_Handler_UART_Receive
 157              		.section	.rodata
 158              		.align	2
 159              	.LC3:
 160 002c 2563203A 		.ascii	"%c : %hu\000"
 160      20256875 
 160      00
 161 0035 000000   		.align	2
 162              	.LC4:
 163 0038 4572726F 		.ascii	"Error! incorrect data. Did you type a number after "
 163      72212069 
 163      6E636F72 
 163      72656374 
 163      20646174 
 164 006b 61202870 		.ascii	"a (p or d), a colon, and the spaces between?\015\012"
 164      206F7220 
 164      64292C20 
 164      6120636F 
 164      6C6F6E2C 
 165 0099 00       		.ascii	"\000"
 166 009a 0000     		.align	2
 167              	.LC5:
 168 009c 50574D20 		.ascii	"PWM now has a period of: %i \015\012\000"
 168      6E6F7720 
 168      68617320 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 7


 168      61207065 
 168      72696F64 
 169 00bb 00       		.align	2
 170              	.LC6:
 171 00bc 50574D20 		.ascii	"PWM now has a duty cycle (in clock ticks) of: %i \015"
 171      6E6F7720 
 171      68617320 
 171      61206475 
 171      74792063 
 172 00ee 0A00     		.ascii	"\012\000"
 173              		.align	2
 174              	.LC7:
 175 00f0 4572726F 		.ascii	"Error! You didn't type a p or d. \015\012\000"
 175      72212059 
 175      6F752064 
 175      69646E27 
 175      74207479 
 176              		.section	.text.Write_PWM_and_UART,"ax",%progbits
 177              		.align	2
 178              		.global	Write_PWM_and_UART
 179              		.thumb
 180              		.thumb_func
 181              		.type	Write_PWM_and_UART, %function
 182              	Write_PWM_and_UART:
 183              	.LFB57:
 147:.\uart_helper_fcns.c **** 
 148:.\uart_helper_fcns.c **** // Helper function that does the writing to the PWM and UART.
 149:.\uart_helper_fcns.c **** // makes the ISR code easier to understand.
 150:.\uart_helper_fcns.c **** void Write_PWM_and_UART(){
 184              		.loc 1 150 0
 185              		.cfi_startproc
 186              		@ args = 0, pretend = 0, frame = 8
 187              		@ frame_needed = 1, uses_anonymous_args = 0
 188 0000 B0B5     		push	{r4, r5, r7, lr}
 189              		.cfi_def_cfa_offset 16
 190              		.cfi_offset 4, -16
 191              		.cfi_offset 5, -12
 192              		.cfi_offset 7, -8
 193              		.cfi_offset 14, -4
 194 0002 82B0     		sub	sp, sp, #8
 195              		.cfi_def_cfa_offset 24
 196 0004 00AF     		add	r7, sp, #0
 197              		.cfi_def_cfa_register 7
 151:.\uart_helper_fcns.c ****     // OK, so now, we have a string in the receive buffer of the form "(p/d):somenumber".
 152:.\uart_helper_fcns.c ****     // To help you out, reply with the string that was received:
 153:.\uart_helper_fcns.c ****     /*
 154:.\uart_helper_fcns.c ****     UART_for_USB_PutString("Received the string: ");
 155:.\uart_helper_fcns.c ****     UART_for_USB_PutString( receive_buffer );
 156:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
 157:.\uart_helper_fcns.c ****     */
 158:.\uart_helper_fcns.c ****     
 159:.\uart_helper_fcns.c ****     // Read in both the mode (p or d) and the integer afterward
 160:.\uart_helper_fcns.c ****     // The %c specified is for a single character
 161:.\uart_helper_fcns.c ****     // The %hu specifier is for unsigned shorts (16 bit integers)
 162:.\uart_helper_fcns.c ****     // A good resource on scanf and printf specifiers is https://www.tutorialspoint.com/c_standard_
 163:.\uart_helper_fcns.c ****     // Let's receive back the number of integers returned from sscanf
 164:.\uart_helper_fcns.c ****     int num_var_filled;
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 8


 165:.\uart_helper_fcns.c ****     // actually scan in the character and integer
 166:.\uart_helper_fcns.c ****     num_var_filled = sscanf( receive_buffer, "%c : %hu", &mode, &data);
 198              		.loc 1 166 0
 199 0006 2948     		ldr	r0, .L17
 200 0008 2949     		ldr	r1, .L17+4
 201 000a 2A4A     		ldr	r2, .L17+8
 202 000c 2A4B     		ldr	r3, .L17+12
 203 000e FFF7FEFF 		bl	sscanf
 204 0012 7860     		str	r0, [r7, #4]
 167:.\uart_helper_fcns.c ****     // Need to check: was anything received? Equivalently, did sscanf find exactly one character, a
 168:.\uart_helper_fcns.c ****     if( num_var_filled != 2){
 205              		.loc 1 168 0
 206 0014 7B68     		ldr	r3, [r7, #4]
 207 0016 022B     		cmp	r3, #2
 208 0018 05D0     		beq	.L11
 169:.\uart_helper_fcns.c ****         UART_for_USB_PutString("Error! incorrect data. Did you type a number after a (p or d), a co
 209              		.loc 1 169 0
 210 001a 2848     		ldr	r0, .L17+16
 211 001c FFF7FEFF 		bl	UART_for_USB_PutString
 170:.\uart_helper_fcns.c ****         data = 0;
 212              		.loc 1 170 0
 213 0020 254B     		ldr	r3, .L17+12
 214 0022 0022     		movs	r2, #0
 215 0024 1A80     		strh	r2, [r3]	@ movhi
 216              	.L11:
 171:.\uart_helper_fcns.c ****     }
 172:.\uart_helper_fcns.c ****     
 173:.\uart_helper_fcns.c ****     // Depending on the mode, write either the data or the duty cycle:
 174:.\uart_helper_fcns.c ****     switch( mode )
 217              		.loc 1 174 0
 218 0026 234B     		ldr	r3, .L17+8
 219 0028 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 220 002a 642B     		cmp	r3, #100
 221 002c 11D0     		beq	.L13
 222 002e 702B     		cmp	r3, #112
 223 0030 1FD1     		bne	.L16
 224              	.LBB2:
 175:.\uart_helper_fcns.c ****     {
 176:.\uart_helper_fcns.c ****         case 'p':
 177:.\uart_helper_fcns.c ****             // Now, set the data, 
 178:.\uart_helper_fcns.c ****             PWM_Servo_WritePeriod( data );
 225              		.loc 1 178 0
 226 0032 214B     		ldr	r3, .L17+12
 227 0034 1B88     		ldrh	r3, [r3]
 228 0036 1846     		mov	r0, r3
 229 0038 FFF7FEFF 		bl	PWM_Servo_WritePeriod
 179:.\uart_helper_fcns.c ****             // and send back the data that was just written, for confirmation.
 180:.\uart_helper_fcns.c ****             // In C, to concatenate a number (integer) and a string (characters), you need to...
 181:.\uart_helper_fcns.c ****             // (1) store the result, as confirmed by the PWM component.
 182:.\uart_helper_fcns.c ****             uint16 period_written = PWM_Servo_ReadPeriod();
 230              		.loc 1 182 0
 231 003c FFF7FEFF 		bl	PWM_Servo_ReadPeriod
 232 0040 0346     		mov	r3, r0
 233 0042 7B80     		strh	r3, [r7, #2]	@ movhi
 183:.\uart_helper_fcns.c ****             // (2) Concatenate this data with a string of characters describing what we did
 184:.\uart_helper_fcns.c ****             // Requires stdio.h (standard input/output) for the sprintf function.
 185:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "PWM now has a period of: %i \r\n", period_written);
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 9


 234              		.loc 1 185 0
 235 0044 7B88     		ldrh	r3, [r7, #2]
 236 0046 1E48     		ldr	r0, .L17+20
 237 0048 1E49     		ldr	r1, .L17+24
 238 004a 1A46     		mov	r2, r3
 239 004c FFF7FEFF 		bl	sprintf
 186:.\uart_helper_fcns.c ****             break;
 240              		.loc 1 186 0
 241 0050 1DE0     		b	.L15
 242              	.L13:
 187:.\uart_helper_fcns.c ****         case 'd':
 188:.\uart_helper_fcns.c ****             // Instead, set the compare value, the duty cycle in clock ticks.
 189:.\uart_helper_fcns.c ****             PWM_Servo_WriteCompare( data );
 243              		.loc 1 189 0
 244 0052 194B     		ldr	r3, .L17+12
 245 0054 1B88     		ldrh	r3, [r3]
 246 0056 1846     		mov	r0, r3
 247 0058 FFF7FEFF 		bl	PWM_Servo_WriteCompare
 190:.\uart_helper_fcns.c ****             // Like with the period:
 191:.\uart_helper_fcns.c ****             uint16 duty_written = PWM_Servo_ReadCompare();
 248              		.loc 1 191 0
 249 005c FFF7FEFF 		bl	PWM_Servo_ReadCompare
 250 0060 0346     		mov	r3, r0
 251 0062 3B80     		strh	r3, [r7]	@ movhi
 192:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "PWM now has a duty cycle (in clock ticks) of: %i \r\n", duty
 252              		.loc 1 192 0
 253 0064 3B88     		ldrh	r3, [r7]
 254 0066 1648     		ldr	r0, .L17+20
 255 0068 1749     		ldr	r1, .L17+28
 256 006a 1A46     		mov	r2, r3
 257 006c FFF7FEFF 		bl	sprintf
 193:.\uart_helper_fcns.c ****             break;
 258              		.loc 1 193 0
 259 0070 0DE0     		b	.L15
 260              	.L16:
 194:.\uart_helper_fcns.c ****         default:
 195:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "Error! You didn't type a p or d. \r\n");
 261              		.loc 1 195 0
 262 0072 134A     		ldr	r2, .L17+20
 263 0074 154B     		ldr	r3, .L17+32
 264 0076 1446     		mov	r4, r2
 265 0078 1D46     		mov	r5, r3
 266 007a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 267 007c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 268 007e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 269 0080 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 270 0082 2B68     		ldr	r3, [r5]
 271 0084 2360     		str	r3, [r4]
 196:.\uart_helper_fcns.c ****             mode = 0;
 272              		.loc 1 196 0
 273 0086 0B4B     		ldr	r3, .L17+8
 274 0088 0022     		movs	r2, #0
 275 008a 1A70     		strb	r2, [r3]
 197:.\uart_helper_fcns.c ****             break;
 276              		.loc 1 197 0
 277 008c 00BF     		nop
 278              	.L15:
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 10


 279              	.LBE2:
 198:.\uart_helper_fcns.c ****     }
 199:.\uart_helper_fcns.c ****     
 200:.\uart_helper_fcns.c ****     // sscanf requires the address-of (&) for the variable to be written.
 201:.\uart_helper_fcns.c ****     
 202:.\uart_helper_fcns.c ****     
 203:.\uart_helper_fcns.c ****     // (3) send the byte back to your PC
 204:.\uart_helper_fcns.c ****     UART_for_USB_PutString( transmit_buffer );    
 280              		.loc 1 204 0
 281 008e 0C48     		ldr	r0, .L17+20
 282 0090 FFF7FEFF 		bl	UART_for_USB_PutString
 205:.\uart_helper_fcns.c ****     // to make this easier to read, send another newline.
 206:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
 283              		.loc 1 206 0
 284 0094 0E48     		ldr	r0, .L17+36
 285 0096 FFF7FEFF 		bl	UART_for_USB_PutString
 207:.\uart_helper_fcns.c ****     // (4) Send another little string prompting the next input.
 208:.\uart_helper_fcns.c ****     //UART_for_USB_PutString( " by typing p: then a new data, between 100 and 200 (min and max data
 209:.\uart_helper_fcns.c ****     // Reset the indexing into the array
 210:.\uart_helper_fcns.c ****     num_chars_received = 0;
 286              		.loc 1 210 0
 287 009a 0E4B     		ldr	r3, .L17+40
 288 009c 0022     		movs	r2, #0
 289 009e 1A70     		strb	r2, [r3]
 211:.\uart_helper_fcns.c ****     // and just in case let's do the data too.
 212:.\uart_helper_fcns.c ****     data = 0;
 290              		.loc 1 212 0
 291 00a0 054B     		ldr	r3, .L17+12
 292 00a2 0022     		movs	r2, #0
 293 00a4 1A80     		strh	r2, [r3]	@ movhi
 213:.\uart_helper_fcns.c ****     // Note that we don't have to reset the buffer here, since sscanf only reads up until the first
 214:.\uart_helper_fcns.c **** }
 294              		.loc 1 214 0
 295 00a6 0837     		adds	r7, r7, #8
 296 00a8 BD46     		mov	sp, r7
 297              		@ sp needed
 298 00aa B0BD     		pop	{r4, r5, r7, pc}
 299              	.L18:
 300              		.align	2
 301              	.L17:
 302 00ac 80000000 		.word	receive_buffer
 303 00b0 2C000000 		.word	.LC3
 304 00b4 04010000 		.word	mode
 305 00b8 02010000 		.word	data
 306 00bc 38000000 		.word	.LC4
 307 00c0 00000000 		.word	transmit_buffer
 308 00c4 9C000000 		.word	.LC5
 309 00c8 BC000000 		.word	.LC6
 310 00cc F0000000 		.word	.LC7
 311 00d0 00000000 		.word	.LC0
 312 00d4 00010000 		.word	num_chars_received
 313              		.cfi_endproc
 314              	.LFE57:
 315              		.size	Write_PWM_and_UART, .-Write_PWM_and_UART
 316              		.text
 317              	.Letext0:
 318              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 11


 319              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
 320              		.file 4 ".\\Generated_Source\\PSoC5/cytypes.h"
 321              		.file 5 ".\\Generated_Source\\PSoC5/core_cm3.h"
 322              		.section	.debug_info,"",%progbits
 323              	.Ldebug_info0:
 324 0000 94010000 		.4byte	0x194
 325 0004 0400     		.2byte	0x4
 326 0006 00000000 		.4byte	.Ldebug_abbrev0
 327 000a 04       		.byte	0x4
 328 000b 01       		.uleb128 0x1
 329 000c 65000000 		.4byte	.LASF26
 330 0010 01       		.byte	0x1
 331 0011 1F020000 		.4byte	.LASF27
 332 0015 E1000000 		.4byte	.LASF28
 333 0019 00000000 		.4byte	.Ldebug_ranges0+0
 334 001d 00000000 		.4byte	0
 335 0021 00000000 		.4byte	.Ldebug_line0
 336 0025 02       		.uleb128 0x2
 337 0026 01       		.byte	0x1
 338 0027 06       		.byte	0x6
 339 0028 2B000000 		.4byte	.LASF0
 340 002c 02       		.uleb128 0x2
 341 002d 01       		.byte	0x1
 342 002e 08       		.byte	0x8
 343 002f 44000000 		.4byte	.LASF1
 344 0033 02       		.uleb128 0x2
 345 0034 02       		.byte	0x2
 346 0035 05       		.byte	0x5
 347 0036 06020000 		.4byte	.LASF2
 348 003a 02       		.uleb128 0x2
 349 003b 02       		.byte	0x2
 350 003c 07       		.byte	0x7
 351 003d 22010000 		.4byte	.LASF3
 352 0041 03       		.uleb128 0x3
 353 0042 00000000 		.4byte	.LASF9
 354 0046 02       		.byte	0x2
 355 0047 37       		.byte	0x37
 356 0048 4C000000 		.4byte	0x4c
 357 004c 02       		.uleb128 0x2
 358 004d 04       		.byte	0x4
 359 004e 05       		.byte	0x5
 360 004f 16020000 		.4byte	.LASF4
 361 0053 02       		.uleb128 0x2
 362 0054 04       		.byte	0x4
 363 0055 07       		.byte	0x7
 364 0056 83010000 		.4byte	.LASF5
 365 005a 02       		.uleb128 0x2
 366 005b 08       		.byte	0x8
 367 005c 05       		.byte	0x5
 368 005d F3010000 		.4byte	.LASF6
 369 0061 02       		.uleb128 0x2
 370 0062 08       		.byte	0x8
 371 0063 07       		.byte	0x7
 372 0064 A9010000 		.4byte	.LASF7
 373 0068 04       		.uleb128 0x4
 374 0069 04       		.byte	0x4
 375 006a 05       		.byte	0x5
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 12


 376 006b 696E7400 		.ascii	"int\000"
 377 006f 02       		.uleb128 0x2
 378 0070 04       		.byte	0x4
 379 0071 07       		.byte	0x7
 380 0072 9C010000 		.4byte	.LASF8
 381 0076 03       		.uleb128 0x3
 382 0077 E2010000 		.4byte	.LASF10
 383 007b 03       		.byte	0x3
 384 007c 41       		.byte	0x41
 385 007d 41000000 		.4byte	0x41
 386 0081 03       		.uleb128 0x3
 387 0082 10020000 		.4byte	.LASF11
 388 0086 04       		.byte	0x4
 389 0087 A1       		.byte	0xa1
 390 0088 2C000000 		.4byte	0x2c
 391 008c 03       		.uleb128 0x3
 392 008d 95010000 		.4byte	.LASF12
 393 0091 04       		.byte	0x4
 394 0092 A2       		.byte	0xa2
 395 0093 3A000000 		.4byte	0x3a
 396 0097 02       		.uleb128 0x2
 397 0098 04       		.byte	0x4
 398 0099 04       		.byte	0x4
 399 009a 20000000 		.4byte	.LASF13
 400 009e 02       		.uleb128 0x2
 401 009f 08       		.byte	0x8
 402 00a0 04       		.byte	0x4
 403 00a1 19000000 		.4byte	.LASF14
 404 00a5 02       		.uleb128 0x2
 405 00a6 01       		.byte	0x1
 406 00a7 08       		.byte	0x8
 407 00a8 01020000 		.4byte	.LASF15
 408 00ac 02       		.uleb128 0x2
 409 00ad 04       		.byte	0x4
 410 00ae 07       		.byte	0x7
 411 00af EA010000 		.4byte	.LASF16
 412 00b3 05       		.uleb128 0x5
 413 00b4 51010000 		.4byte	.LASF29
 414 00b8 01       		.byte	0x1
 415 00b9 45       		.byte	0x45
 416 00ba 00000000 		.4byte	.LFB56
 417 00be 9C000000 		.4byte	.LFE56-.LFB56
 418 00c2 01       		.uleb128 0x1
 419 00c3 9C       		.byte	0x9c
 420 00c4 D7000000 		.4byte	0xd7
 421 00c8 06       		.uleb128 0x6
 422 00c9 D4010000 		.4byte	.LASF17
 423 00cd 01       		.byte	0x1
 424 00ce 48       		.byte	0x48
 425 00cf 81000000 		.4byte	0x81
 426 00d3 02       		.uleb128 0x2
 427 00d4 91       		.byte	0x91
 428 00d5 77       		.sleb128 -9
 429 00d6 00       		.byte	0
 430 00d7 07       		.uleb128 0x7
 431 00d8 52000000 		.4byte	.LASF30
 432 00dc 01       		.byte	0x1
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 13


 433 00dd 96       		.byte	0x96
 434 00de 00000000 		.4byte	.LFB57
 435 00e2 D8000000 		.4byte	.LFE57-.LFB57
 436 00e6 01       		.uleb128 0x1
 437 00e7 9C       		.byte	0x9c
 438 00e8 21010000 		.4byte	0x121
 439 00ec 06       		.uleb128 0x6
 440 00ed C5010000 		.4byte	.LASF18
 441 00f1 01       		.byte	0x1
 442 00f2 A4       		.byte	0xa4
 443 00f3 68000000 		.4byte	0x68
 444 00f7 02       		.uleb128 0x2
 445 00f8 91       		.byte	0x91
 446 00f9 6C       		.sleb128 -20
 447 00fa 08       		.uleb128 0x8
 448 00fb 32000000 		.4byte	.LBB2
 449 00ff 5C000000 		.4byte	.LBE2-.LBB2
 450 0103 06       		.uleb128 0x6
 451 0104 0A000000 		.4byte	.LASF19
 452 0108 01       		.byte	0x1
 453 0109 B6       		.byte	0xb6
 454 010a 8C000000 		.4byte	0x8c
 455 010e 02       		.uleb128 0x2
 456 010f 91       		.byte	0x91
 457 0110 6A       		.sleb128 -22
 458 0111 06       		.uleb128 0x6
 459 0112 37000000 		.4byte	.LASF20
 460 0116 01       		.byte	0x1
 461 0117 BF       		.byte	0xbf
 462 0118 8C000000 		.4byte	0x8c
 463 011c 02       		.uleb128 0x2
 464 011d 91       		.byte	0x91
 465 011e 68       		.sleb128 -24
 466 011f 00       		.byte	0
 467 0120 00       		.byte	0
 468 0121 09       		.uleb128 0x9
 469 0122 A5000000 		.4byte	0xa5
 470 0126 31010000 		.4byte	0x131
 471 012a 0A       		.uleb128 0xa
 472 012b AC000000 		.4byte	0xac
 473 012f 7F       		.byte	0x7f
 474 0130 00       		.byte	0
 475 0131 06       		.uleb128 0x6
 476 0132 34020000 		.4byte	.LASF21
 477 0136 01       		.byte	0x1
 478 0137 2B       		.byte	0x2b
 479 0138 21010000 		.4byte	0x121
 480 013c 05       		.uleb128 0x5
 481 013d 03       		.byte	0x3
 482 013e 00000000 		.4byte	transmit_buffer
 483 0142 06       		.uleb128 0x6
 484 0143 35010000 		.4byte	.LASF22
 485 0147 01       		.byte	0x1
 486 0148 2D       		.byte	0x2d
 487 0149 21010000 		.4byte	0x121
 488 014d 05       		.uleb128 0x5
 489 014e 03       		.byte	0x3
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 14


 490 014f 80000000 		.4byte	receive_buffer
 491 0153 06       		.uleb128 0x6
 492 0154 70010000 		.4byte	.LASF23
 493 0158 01       		.byte	0x1
 494 0159 36       		.byte	0x36
 495 015a 81000000 		.4byte	0x81
 496 015e 05       		.uleb128 0x5
 497 015f 03       		.byte	0x3
 498 0160 00010000 		.4byte	num_chars_received
 499 0164 06       		.uleb128 0x6
 500 0165 26000000 		.4byte	.LASF24
 501 0169 01       		.byte	0x1
 502 016a 3C       		.byte	0x3c
 503 016b 8C000000 		.4byte	0x8c
 504 016f 05       		.uleb128 0x5
 505 0170 03       		.byte	0x3
 506 0171 02010000 		.4byte	data
 507 0175 06       		.uleb128 0x6
 508 0176 C0010000 		.4byte	.LASF25
 509 017a 01       		.byte	0x1
 510 017b 40       		.byte	0x40
 511 017c A5000000 		.4byte	0xa5
 512 0180 05       		.uleb128 0x5
 513 0181 03       		.byte	0x3
 514 0182 04010000 		.4byte	mode
 515 0186 0B       		.uleb128 0xb
 516 0187 44010000 		.4byte	.LASF31
 517 018b 05       		.byte	0x5
 518 018c 1606     		.2byte	0x616
 519 018e 92010000 		.4byte	0x192
 520 0192 0C       		.uleb128 0xc
 521 0193 76000000 		.4byte	0x76
 522 0197 00       		.byte	0
 523              		.section	.debug_abbrev,"",%progbits
 524              	.Ldebug_abbrev0:
 525 0000 01       		.uleb128 0x1
 526 0001 11       		.uleb128 0x11
 527 0002 01       		.byte	0x1
 528 0003 25       		.uleb128 0x25
 529 0004 0E       		.uleb128 0xe
 530 0005 13       		.uleb128 0x13
 531 0006 0B       		.uleb128 0xb
 532 0007 03       		.uleb128 0x3
 533 0008 0E       		.uleb128 0xe
 534 0009 1B       		.uleb128 0x1b
 535 000a 0E       		.uleb128 0xe
 536 000b 55       		.uleb128 0x55
 537 000c 17       		.uleb128 0x17
 538 000d 11       		.uleb128 0x11
 539 000e 01       		.uleb128 0x1
 540 000f 10       		.uleb128 0x10
 541 0010 17       		.uleb128 0x17
 542 0011 00       		.byte	0
 543 0012 00       		.byte	0
 544 0013 02       		.uleb128 0x2
 545 0014 24       		.uleb128 0x24
 546 0015 00       		.byte	0
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 15


 547 0016 0B       		.uleb128 0xb
 548 0017 0B       		.uleb128 0xb
 549 0018 3E       		.uleb128 0x3e
 550 0019 0B       		.uleb128 0xb
 551 001a 03       		.uleb128 0x3
 552 001b 0E       		.uleb128 0xe
 553 001c 00       		.byte	0
 554 001d 00       		.byte	0
 555 001e 03       		.uleb128 0x3
 556 001f 16       		.uleb128 0x16
 557 0020 00       		.byte	0
 558 0021 03       		.uleb128 0x3
 559 0022 0E       		.uleb128 0xe
 560 0023 3A       		.uleb128 0x3a
 561 0024 0B       		.uleb128 0xb
 562 0025 3B       		.uleb128 0x3b
 563 0026 0B       		.uleb128 0xb
 564 0027 49       		.uleb128 0x49
 565 0028 13       		.uleb128 0x13
 566 0029 00       		.byte	0
 567 002a 00       		.byte	0
 568 002b 04       		.uleb128 0x4
 569 002c 24       		.uleb128 0x24
 570 002d 00       		.byte	0
 571 002e 0B       		.uleb128 0xb
 572 002f 0B       		.uleb128 0xb
 573 0030 3E       		.uleb128 0x3e
 574 0031 0B       		.uleb128 0xb
 575 0032 03       		.uleb128 0x3
 576 0033 08       		.uleb128 0x8
 577 0034 00       		.byte	0
 578 0035 00       		.byte	0
 579 0036 05       		.uleb128 0x5
 580 0037 2E       		.uleb128 0x2e
 581 0038 01       		.byte	0x1
 582 0039 3F       		.uleb128 0x3f
 583 003a 19       		.uleb128 0x19
 584 003b 03       		.uleb128 0x3
 585 003c 0E       		.uleb128 0xe
 586 003d 3A       		.uleb128 0x3a
 587 003e 0B       		.uleb128 0xb
 588 003f 3B       		.uleb128 0x3b
 589 0040 0B       		.uleb128 0xb
 590 0041 27       		.uleb128 0x27
 591 0042 19       		.uleb128 0x19
 592 0043 11       		.uleb128 0x11
 593 0044 01       		.uleb128 0x1
 594 0045 12       		.uleb128 0x12
 595 0046 06       		.uleb128 0x6
 596 0047 40       		.uleb128 0x40
 597 0048 18       		.uleb128 0x18
 598 0049 9642     		.uleb128 0x2116
 599 004b 19       		.uleb128 0x19
 600 004c 01       		.uleb128 0x1
 601 004d 13       		.uleb128 0x13
 602 004e 00       		.byte	0
 603 004f 00       		.byte	0
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 16


 604 0050 06       		.uleb128 0x6
 605 0051 34       		.uleb128 0x34
 606 0052 00       		.byte	0
 607 0053 03       		.uleb128 0x3
 608 0054 0E       		.uleb128 0xe
 609 0055 3A       		.uleb128 0x3a
 610 0056 0B       		.uleb128 0xb
 611 0057 3B       		.uleb128 0x3b
 612 0058 0B       		.uleb128 0xb
 613 0059 49       		.uleb128 0x49
 614 005a 13       		.uleb128 0x13
 615 005b 02       		.uleb128 0x2
 616 005c 18       		.uleb128 0x18
 617 005d 00       		.byte	0
 618 005e 00       		.byte	0
 619 005f 07       		.uleb128 0x7
 620 0060 2E       		.uleb128 0x2e
 621 0061 01       		.byte	0x1
 622 0062 3F       		.uleb128 0x3f
 623 0063 19       		.uleb128 0x19
 624 0064 03       		.uleb128 0x3
 625 0065 0E       		.uleb128 0xe
 626 0066 3A       		.uleb128 0x3a
 627 0067 0B       		.uleb128 0xb
 628 0068 3B       		.uleb128 0x3b
 629 0069 0B       		.uleb128 0xb
 630 006a 11       		.uleb128 0x11
 631 006b 01       		.uleb128 0x1
 632 006c 12       		.uleb128 0x12
 633 006d 06       		.uleb128 0x6
 634 006e 40       		.uleb128 0x40
 635 006f 18       		.uleb128 0x18
 636 0070 9642     		.uleb128 0x2116
 637 0072 19       		.uleb128 0x19
 638 0073 01       		.uleb128 0x1
 639 0074 13       		.uleb128 0x13
 640 0075 00       		.byte	0
 641 0076 00       		.byte	0
 642 0077 08       		.uleb128 0x8
 643 0078 0B       		.uleb128 0xb
 644 0079 01       		.byte	0x1
 645 007a 11       		.uleb128 0x11
 646 007b 01       		.uleb128 0x1
 647 007c 12       		.uleb128 0x12
 648 007d 06       		.uleb128 0x6
 649 007e 00       		.byte	0
 650 007f 00       		.byte	0
 651 0080 09       		.uleb128 0x9
 652 0081 01       		.uleb128 0x1
 653 0082 01       		.byte	0x1
 654 0083 49       		.uleb128 0x49
 655 0084 13       		.uleb128 0x13
 656 0085 01       		.uleb128 0x1
 657 0086 13       		.uleb128 0x13
 658 0087 00       		.byte	0
 659 0088 00       		.byte	0
 660 0089 0A       		.uleb128 0xa
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 17


 661 008a 21       		.uleb128 0x21
 662 008b 00       		.byte	0
 663 008c 49       		.uleb128 0x49
 664 008d 13       		.uleb128 0x13
 665 008e 2F       		.uleb128 0x2f
 666 008f 0B       		.uleb128 0xb
 667 0090 00       		.byte	0
 668 0091 00       		.byte	0
 669 0092 0B       		.uleb128 0xb
 670 0093 34       		.uleb128 0x34
 671 0094 00       		.byte	0
 672 0095 03       		.uleb128 0x3
 673 0096 0E       		.uleb128 0xe
 674 0097 3A       		.uleb128 0x3a
 675 0098 0B       		.uleb128 0xb
 676 0099 3B       		.uleb128 0x3b
 677 009a 05       		.uleb128 0x5
 678 009b 49       		.uleb128 0x49
 679 009c 13       		.uleb128 0x13
 680 009d 3F       		.uleb128 0x3f
 681 009e 19       		.uleb128 0x19
 682 009f 3C       		.uleb128 0x3c
 683 00a0 19       		.uleb128 0x19
 684 00a1 00       		.byte	0
 685 00a2 00       		.byte	0
 686 00a3 0C       		.uleb128 0xc
 687 00a4 35       		.uleb128 0x35
 688 00a5 00       		.byte	0
 689 00a6 49       		.uleb128 0x49
 690 00a7 13       		.uleb128 0x13
 691 00a8 00       		.byte	0
 692 00a9 00       		.byte	0
 693 00aa 00       		.byte	0
 694              		.section	.debug_aranges,"",%progbits
 695 0000 24000000 		.4byte	0x24
 696 0004 0200     		.2byte	0x2
 697 0006 00000000 		.4byte	.Ldebug_info0
 698 000a 04       		.byte	0x4
 699 000b 00       		.byte	0
 700 000c 0000     		.2byte	0
 701 000e 0000     		.2byte	0
 702 0010 00000000 		.4byte	.LFB56
 703 0014 9C000000 		.4byte	.LFE56-.LFB56
 704 0018 00000000 		.4byte	.LFB57
 705 001c D8000000 		.4byte	.LFE57-.LFB57
 706 0020 00000000 		.4byte	0
 707 0024 00000000 		.4byte	0
 708              		.section	.debug_ranges,"",%progbits
 709              	.Ldebug_ranges0:
 710 0000 00000000 		.4byte	.LFB56
 711 0004 9C000000 		.4byte	.LFE56
 712 0008 00000000 		.4byte	.LFB57
 713 000c D8000000 		.4byte	.LFE57
 714 0010 00000000 		.4byte	0
 715 0014 00000000 		.4byte	0
 716              		.section	.debug_line,"",%progbits
 717              	.Ldebug_line0:
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 18


 718 0000 B3010000 		.section	.debug_str,"MS",%progbits,1
 718      02005D01 
 718      00000201 
 718      FB0E0D00 
 718      01010101 
 719              	.LASF9:
 720 0000 5F5F696E 		.ascii	"__int32_t\000"
 720      7433325F 
 720      7400
 721              	.LASF19:
 722 000a 70657269 		.ascii	"period_written\000"
 722      6F645F77 
 722      72697474 
 722      656E00
 723              	.LASF14:
 724 0019 646F7562 		.ascii	"double\000"
 724      6C6500
 725              	.LASF13:
 726 0020 666C6F61 		.ascii	"float\000"
 726      7400
 727              	.LASF24:
 728 0026 64617461 		.ascii	"data\000"
 728      00
 729              	.LASF0:
 730 002b 7369676E 		.ascii	"signed char\000"
 730      65642063 
 730      68617200 
 731              	.LASF20:
 732 0037 64757479 		.ascii	"duty_written\000"
 732      5F777269 
 732      7474656E 
 732      00
 733              	.LASF1:
 734 0044 756E7369 		.ascii	"unsigned char\000"
 734      676E6564 
 734      20636861 
 734      7200
 735              	.LASF30:
 736 0052 57726974 		.ascii	"Write_PWM_and_UART\000"
 736      655F5057 
 736      4D5F616E 
 736      645F5541 
 736      525400
 737              	.LASF26:
 738 0065 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 738      4320342E 
 738      382E3420 
 738      32303134 
 738      30353236 
 739 0098 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m3 -mthumb -g -O"
 739      20726576 
 739      6973696F 
 739      6E203231 
 739      31333538 
 740 00cb 30202D66 		.ascii	"0 -ffunction-sections\000"
 740      66756E63 
 740      74696F6E 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 19


 740      2D736563 
 740      74696F6E 
 741              	.LASF28:
 742 00e1 443A5C57 		.ascii	"D:\\WindowsGitHub\\psoc-examples\\me235\\PWM_UART_M"
 742      696E646F 
 742      77734769 
 742      74487562 
 742      5C70736F 
 743 0110 756C7469 		.ascii	"ultitasking.cydsn\000"
 743      7461736B 
 743      696E672E 
 743      63796473 
 743      6E00
 744              	.LASF3:
 745 0122 73686F72 		.ascii	"short unsigned int\000"
 745      7420756E 
 745      7369676E 
 745      65642069 
 745      6E7400
 746              	.LASF22:
 747 0135 72656365 		.ascii	"receive_buffer\000"
 747      6976655F 
 747      62756666 
 747      657200
 748              	.LASF31:
 749 0144 49544D5F 		.ascii	"ITM_RxBuffer\000"
 749      52784275 
 749      66666572 
 749      00
 750              	.LASF29:
 751 0151 496E7465 		.ascii	"Interrupt_Handler_UART_Receive\000"
 751      72727570 
 751      745F4861 
 751      6E646C65 
 751      725F5541 
 752              	.LASF23:
 753 0170 6E756D5F 		.ascii	"num_chars_received\000"
 753      63686172 
 753      735F7265 
 753      63656976 
 753      656400
 754              	.LASF5:
 755 0183 6C6F6E67 		.ascii	"long unsigned int\000"
 755      20756E73 
 755      69676E65 
 755      6420696E 
 755      7400
 756              	.LASF12:
 757 0195 75696E74 		.ascii	"uint16\000"
 757      313600
 758              	.LASF8:
 759 019c 756E7369 		.ascii	"unsigned int\000"
 759      676E6564 
 759      20696E74 
 759      00
 760              	.LASF7:
 761 01a9 6C6F6E67 		.ascii	"long long unsigned int\000"
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccMThKV7.s 			page 20


 761      206C6F6E 
 761      6720756E 
 761      7369676E 
 761      65642069 
 762              	.LASF25:
 763 01c0 6D6F6465 		.ascii	"mode\000"
 763      00
 764              	.LASF18:
 765 01c5 6E756D5F 		.ascii	"num_var_filled\000"
 765      7661725F 
 765      66696C6C 
 765      656400
 766              	.LASF17:
 767 01d4 72656365 		.ascii	"received_byte\000"
 767      69766564 
 767      5F627974 
 767      6500
 768              	.LASF10:
 769 01e2 696E7433 		.ascii	"int32_t\000"
 769      325F7400 
 770              	.LASF16:
 771 01ea 73697A65 		.ascii	"sizetype\000"
 771      74797065 
 771      00
 772              	.LASF6:
 773 01f3 6C6F6E67 		.ascii	"long long int\000"
 773      206C6F6E 
 773      6720696E 
 773      7400
 774              	.LASF15:
 775 0201 63686172 		.ascii	"char\000"
 775      00
 776              	.LASF2:
 777 0206 73686F72 		.ascii	"short int\000"
 777      7420696E 
 777      7400
 778              	.LASF11:
 779 0210 75696E74 		.ascii	"uint8\000"
 779      3800
 780              	.LASF4:
 781 0216 6C6F6E67 		.ascii	"long int\000"
 781      20696E74 
 781      00
 782              	.LASF27:
 783 021f 2E5C7561 		.ascii	".\\uart_helper_fcns.c\000"
 783      72745F68 
 783      656C7065 
 783      725F6663 
 783      6E732E63 
 784              	.LASF21:
 785 0234 7472616E 		.ascii	"transmit_buffer\000"
 785      736D6974 
 785      5F627566 
 785      66657200 
 786              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
