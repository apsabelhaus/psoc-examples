ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"uart_helper_fcns.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.bss
  19              		.align	2
  20              	transmit_buffer:
  21 0000 00000000 		.space	128
  21      00000000 
  21      00000000 
  21      00000000 
  21      00000000 
  22              		.align	2
  23              	receive_buffer:
  24 0080 00000000 		.space	128
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              	num_chars_received:
  26 0100 00       		.space	1
  27 0101 00       		.align	1
  28              	data:
  29 0102 0000     		.space	2
  30              	mode:
  31 0104 00       		.space	1
  32 0105 000000   		.section	.rodata
  33              		.align	2
  34              	.LC0:
  35 0000 0D0A00   		.ascii	"\015\012\000"
  36 0003 00       		.align	2
  37              	.LC1:
  38 0004 0D0A5374 		.ascii	"\015\012Stopping PWM.\015\012\000"
  38      6F707069 
  38      6E672050 
  38      574D2E0D 
  38      0A00
  39 0016 0000     		.align	2
  40              	.LC2:
  41 0018 0D0A5265 		.ascii	"\015\012Restarting PWM.\015\012\000"
  41      73746172 
  41      74696E67 
  41      2050574D 
  41      2E0D0A00 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 2


  42              		.section	.text.Interrupt_Handler_UART_Receive,"ax",%progbits
  43              		.align	2
  44              		.global	Interrupt_Handler_UART_Receive
  45              		.thumb
  46              		.thumb_func
  47              		.type	Interrupt_Handler_UART_Receive, %function
  48              	Interrupt_Handler_UART_Receive:
  49              	.LFB56:
  50              		.file 1 ".\\uart_helper_fcns.c"
   1:.\uart_helper_fcns.c **** /* ========================================
   2:.\uart_helper_fcns.c ****  *
   3:.\uart_helper_fcns.c ****  * Copyright Andrew P. Sabelhaus, 2018 
   4:.\uart_helper_fcns.c ****  * See README and LICENSE for more details.
   5:.\uart_helper_fcns.c ****  *
   6:.\uart_helper_fcns.c ****  * ========================================
   7:.\uart_helper_fcns.c **** */
   8:.\uart_helper_fcns.c **** 
   9:.\uart_helper_fcns.c **** // Code adapted heavily from Cypress' example CE95277 ADC and UART,
  10:.\uart_helper_fcns.c **** // but all re-written by Drew.
  11:.\uart_helper_fcns.c **** 
  12:.\uart_helper_fcns.c **** #include "uart_helper_fcns.h"
  13:.\uart_helper_fcns.c **** #include <project.h>
  14:.\uart_helper_fcns.c **** // stdio.h provides the sprintf and sscanf functions for working with strings.
  15:.\uart_helper_fcns.c **** #include "stdio.h"
  16:.\uart_helper_fcns.c **** 
  17:.\uart_helper_fcns.c **** // We'll store a string for the PSoC-to-PC transmission, with a length of this many characters:
  18:.\uart_helper_fcns.c **** #define TRANSMIT_LENGTH 128
  19:.\uart_helper_fcns.c **** // We'll store a string for the PC-to-PSoC transmission, with a length of this many characters:
  20:.\uart_helper_fcns.c **** #define RECEIVE_LENGTH 128
  21:.\uart_helper_fcns.c **** 
  22:.\uart_helper_fcns.c **** // Strings of characters are often stored in "buffers" as arrays of characters.
  23:.\uart_helper_fcns.c **** static char transmit_buffer[TRANSMIT_LENGTH];
  24:.\uart_helper_fcns.c **** static char receive_buffer[RECEIVE_LENGTH];
  25:.\uart_helper_fcns.c **** 
  26:.\uart_helper_fcns.c **** // We'll keep track of new characters as they're received over the UART, so we need to
  27:.\uart_helper_fcns.c **** // index into the buffer
  28:.\uart_helper_fcns.c **** static uint8 num_chars_received = 0;
  29:.\uart_helper_fcns.c **** 
  30:.\uart_helper_fcns.c **** // the data, as recorded in the helpers below.
  31:.\uart_helper_fcns.c **** // This will be either the period or duty cycle
  32:.\uart_helper_fcns.c **** static uint16 data = 0;
  33:.\uart_helper_fcns.c **** 
  34:.\uart_helper_fcns.c **** // We need to store a character representing the mode, "set period" = p or "set duty cycle" = d
  35:.\uart_helper_fcns.c **** static char mode;
  36:.\uart_helper_fcns.c **** 
  37:.\uart_helper_fcns.c **** /**
  38:.\uart_helper_fcns.c ****  * Definition of the UART ISR
  39:.\uart_helper_fcns.c ****  * We use the same line for the function definition, with the CY_ISR macro.
  40:.\uart_helper_fcns.c ****  * Compare this to tutorial 6, with "pythagorean"
  41:.\uart_helper_fcns.c ****  * This function also repeats characters back to the terminal, so you can see what you're typing.
  42:.\uart_helper_fcns.c ****  * Compare to the code at the end of tutorial 7
  43:.\uart_helper_fcns.c ****  */
  44:.\uart_helper_fcns.c **** CY_ISR( Interrupt_Handler_UART_Receive){
  51              		.loc 1 44 0
  52              		.cfi_startproc
  53              		@ args = 0, pretend = 0, frame = 8
  54              		@ frame_needed = 1, uses_anonymous_args = 0
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 3


  55 0000 80B5     		push	{r7, lr}
  56              		.cfi_def_cfa_offset 8
  57              		.cfi_offset 7, -8
  58              		.cfi_offset 14, -4
  59 0002 82B0     		sub	sp, sp, #8
  60              		.cfi_def_cfa_offset 16
  61 0004 00AF     		add	r7, sp, #0
  62              		.cfi_def_cfa_register 7
  45:.\uart_helper_fcns.c ****     // We assume this ISR is called when a byte is received.
  46:.\uart_helper_fcns.c ****     uint8 received_byte = UART_for_USB_GetChar();
  63              		.loc 1 46 0
  64 0006 FFF7FEFF 		bl	UART_for_USB_GetChar
  65 000a 0346     		mov	r3, r0
  66 000c FB71     		strb	r3, [r7, #7]
  47:.\uart_helper_fcns.c ****     
  48:.\uart_helper_fcns.c ****     // C allows us to "switch" on uint8s, since characters are also numbers via the ASCII table.
  49:.\uart_helper_fcns.c ****     // either add to the buffer, or finally set the PWM parameters, depending on ...
  50:.\uart_helper_fcns.c ****     switch( received_byte )
  67              		.loc 1 50 0
  68 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  69 0010 0D2B     		cmp	r3, #13
  70 0012 09D0     		beq	.L3
  71 0014 0D2B     		cmp	r3, #13
  72 0016 02DC     		bgt	.L4
  73 0018 0A2B     		cmp	r3, #10
  74 001a 05D0     		beq	.L3
  75 001c 21E0     		b	.L2
  76              	.L4:
  77 001e 652B     		cmp	r3, #101
  78 0020 16D0     		beq	.L5
  79 0022 782B     		cmp	r3, #120
  80 0024 0BD0     		beq	.L6
  81 0026 1CE0     		b	.L2
  82              	.L3:
  51:.\uart_helper_fcns.c ****     {
  52:.\uart_helper_fcns.c ****         // Students: look up switch-case statements. to understand this more.
  53:.\uart_helper_fcns.c ****         case '\r':
  54:.\uart_helper_fcns.c ****             // flow downward, no specific code for carriage return
  55:.\uart_helper_fcns.c ****         case '\n':
  56:.\uart_helper_fcns.c ****             // newline or carraige return received, so finally set the PWM parameters
  57:.\uart_helper_fcns.c ****             // First, terminate the string. This is for the use of sscanf below.
  58:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = '\0';
  83              		.loc 1 58 0
  84 0028 174B     		ldr	r3, .L8
  85 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  86 002c 174A     		ldr	r2, .L8+4
  87 002e 0021     		movs	r1, #0
  88 0030 D154     		strb	r1, [r2, r3]
  59:.\uart_helper_fcns.c ****             // Print back the newline/carriage return, to complete the "respond back to the termina
  60:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\n");
  89              		.loc 1 60 0
  90 0032 1748     		ldr	r0, .L8+8
  91 0034 FFF7FEFF 		bl	UART_for_USB_PutString
  61:.\uart_helper_fcns.c ****             // Call the helper function to actually set the PWM
  62:.\uart_helper_fcns.c ****             Write_PWM_and_UART();
  92              		.loc 1 62 0
  93 0038 FFF7FEFF 		bl	Write_PWM_and_UART
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 4


  63:.\uart_helper_fcns.c ****             break;
  94              		.loc 1 63 0
  95 003c 21E0     		b	.L1
  96              	.L6:
  64:.\uart_helper_fcns.c ****         case 'x':
  65:.\uart_helper_fcns.c ****             // Added functionality: if the user types an x, then the PWM stops.
  66:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\nStopping PWM.\r\n");
  97              		.loc 1 66 0
  98 003e 1548     		ldr	r0, .L8+12
  99 0040 FFF7FEFF 		bl	UART_for_USB_PutString
  67:.\uart_helper_fcns.c ****             PWM_Servo_Stop();
 100              		.loc 1 67 0
 101 0044 FFF7FEFF 		bl	PWM_Servo_Stop
  68:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
  69:.\uart_helper_fcns.c ****             num_chars_received = 0;
 102              		.loc 1 69 0
 103 0048 0F4B     		ldr	r3, .L8
 104 004a 0022     		movs	r2, #0
 105 004c 1A70     		strb	r2, [r3]
  70:.\uart_helper_fcns.c ****             break;
 106              		.loc 1 70 0
 107 004e 18E0     		b	.L1
 108              	.L5:
  71:.\uart_helper_fcns.c ****         case 'e':
  72:.\uart_helper_fcns.c ****             // Similarly, type e to enable.
  73:.\uart_helper_fcns.c ****             UART_for_USB_PutString("\r\nRestarting PWM.\r\n");
 109              		.loc 1 73 0
 110 0050 1148     		ldr	r0, .L8+16
 111 0052 FFF7FEFF 		bl	UART_for_USB_PutString
  74:.\uart_helper_fcns.c ****             PWM_Servo_Start();
 112              		.loc 1 74 0
 113 0056 FFF7FEFF 		bl	PWM_Servo_Start
  75:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
  76:.\uart_helper_fcns.c ****             num_chars_received = 0;
 114              		.loc 1 76 0
 115 005a 0B4B     		ldr	r3, .L8
 116 005c 0022     		movs	r2, #0
 117 005e 1A70     		strb	r2, [r3]
  77:.\uart_helper_fcns.c ****             break;
 118              		.loc 1 77 0
 119 0060 0FE0     		b	.L1
 120              	.L2:
  78:.\uart_helper_fcns.c ****         default:
  79:.\uart_helper_fcns.c ****             // The "default" case is "anything else", which is "store another character."
  80:.\uart_helper_fcns.c ****             // Add to the received buffer.
  81:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = received_byte;
 121              		.loc 1 81 0
 122 0062 094B     		ldr	r3, .L8
 123 0064 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 124 0066 094A     		ldr	r2, .L8+4
 125 0068 F979     		ldrb	r1, [r7, #7]
 126 006a D154     		strb	r1, [r2, r3]
  82:.\uart_helper_fcns.c ****             // Respond back to the terminal
  83:.\uart_helper_fcns.c ****             UART_for_USB_PutChar( received_byte );
 127              		.loc 1 83 0
 128 006c FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
 129 006e 1846     		mov	r0, r3
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 5


 130 0070 FFF7FEFF 		bl	UART_for_USB_PutChar
  84:.\uart_helper_fcns.c ****             // We need to increment the counter. i++ does this without an equals sign for assignmen
  85:.\uart_helper_fcns.c ****             num_chars_received++;
 131              		.loc 1 85 0
 132 0074 044B     		ldr	r3, .L8
 133 0076 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 134 0078 0133     		adds	r3, r3, #1
 135 007a DAB2     		uxtb	r2, r3
 136 007c 024B     		ldr	r3, .L8
 137 007e 1A70     		strb	r2, [r3]
  86:.\uart_helper_fcns.c ****             break;
 138              		.loc 1 86 0
 139 0080 00BF     		nop
 140              	.L1:
  87:.\uart_helper_fcns.c ****         // end of case statement.
  88:.\uart_helper_fcns.c ****     }
  89:.\uart_helper_fcns.c **** }
 141              		.loc 1 89 0
 142 0082 0837     		adds	r7, r7, #8
 143 0084 BD46     		mov	sp, r7
 144              		@ sp needed
 145 0086 80BD     		pop	{r7, pc}
 146              	.L9:
 147              		.align	2
 148              	.L8:
 149 0088 00010000 		.word	num_chars_received
 150 008c 80000000 		.word	receive_buffer
 151 0090 00000000 		.word	.LC0
 152 0094 04000000 		.word	.LC1
 153 0098 18000000 		.word	.LC2
 154              		.cfi_endproc
 155              	.LFE56:
 156              		.size	Interrupt_Handler_UART_Receive, .-Interrupt_Handler_UART_Receive
 157              		.section	.rodata
 158              		.align	2
 159              	.LC3:
 160 002c 2563203A 		.ascii	"%c : %hu\000"
 160      20256875 
 160      00
 161 0035 000000   		.align	2
 162              	.LC4:
 163 0038 4572726F 		.ascii	"Error! incorrect data. Did you type a number after "
 163      72212069 
 163      6E636F72 
 163      72656374 
 163      20646174 
 164 006b 61202870 		.ascii	"a (p or d), a colon, and the spaces between?\015\012"
 164      206F7220 
 164      64292C20 
 164      6120636F 
 164      6C6F6E2C 
 165 0099 00       		.ascii	"\000"
 166 009a 0000     		.align	2
 167              	.LC5:
 168 009c 50574D20 		.ascii	"PWM now has a period of: %i \015\012\000"
 168      6E6F7720 
 168      68617320 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 6


 168      61207065 
 168      72696F64 
 169 00bb 00       		.align	2
 170              	.LC6:
 171 00bc 50574D20 		.ascii	"PWM now has a duty cycle (in clock ticks) of: %i \015"
 171      6E6F7720 
 171      68617320 
 171      61206475 
 171      74792063 
 172 00ee 0A00     		.ascii	"\012\000"
 173              		.align	2
 174              	.LC7:
 175 00f0 4572726F 		.ascii	"Error! You didn't type a p or d. \015\012\000"
 175      72212059 
 175      6F752064 
 175      69646E27 
 175      74207479 
 176              		.section	.text.Write_PWM_and_UART,"ax",%progbits
 177              		.align	2
 178              		.global	Write_PWM_and_UART
 179              		.thumb
 180              		.thumb_func
 181              		.type	Write_PWM_and_UART, %function
 182              	Write_PWM_and_UART:
 183              	.LFB57:
  90:.\uart_helper_fcns.c **** 
  91:.\uart_helper_fcns.c **** /**
  92:.\uart_helper_fcns.c ****  * Helper function that does the writing to the PWM.
  93:.\uart_helper_fcns.c ****  * makes the ISR code easier to understand.
  94:.\uart_helper_fcns.c ****  */
  95:.\uart_helper_fcns.c **** void Write_PWM_and_UART(){
 184              		.loc 1 95 0
 185              		.cfi_startproc
 186              		@ args = 0, pretend = 0, frame = 8
 187              		@ frame_needed = 1, uses_anonymous_args = 0
 188 0000 B0B5     		push	{r4, r5, r7, lr}
 189              		.cfi_def_cfa_offset 16
 190              		.cfi_offset 4, -16
 191              		.cfi_offset 5, -12
 192              		.cfi_offset 7, -8
 193              		.cfi_offset 14, -4
 194 0002 82B0     		sub	sp, sp, #8
 195              		.cfi_def_cfa_offset 24
 196 0004 00AF     		add	r7, sp, #0
 197              		.cfi_def_cfa_register 7
  96:.\uart_helper_fcns.c ****     // OK, so now, we have a string in the receive buffer,
  97:.\uart_helper_fcns.c ****     // ideally of the form "(p/d) : somenumber".
  98:.\uart_helper_fcns.c ****     
  99:.\uart_helper_fcns.c ****     // Read in both the mode (p or d) and the integer afterward. Need to check if both were read in
 100:.\uart_helper_fcns.c ****     int num_var_filled;
 101:.\uart_helper_fcns.c ****     // actually scan in the character and integer. See documentation for the sscanf function.
 102:.\uart_helper_fcns.c ****     // sscanf requires the address-of (&) for the variable to be written.
 103:.\uart_helper_fcns.c ****     num_var_filled = sscanf( receive_buffer, "%c : %hu", &mode, &data);
 198              		.loc 1 103 0
 199 0006 2948     		ldr	r0, .L17
 200 0008 2949     		ldr	r1, .L17+4
 201 000a 2A4A     		ldr	r2, .L17+8
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 7


 202 000c 2A4B     		ldr	r3, .L17+12
 203 000e FFF7FEFF 		bl	sscanf
 204 0012 7860     		str	r0, [r7, #4]
 104:.\uart_helper_fcns.c ****     // Need to check: was anything received? Equivalently, did sscanf find exactly one character, a
 105:.\uart_helper_fcns.c ****     if( num_var_filled != 2){
 205              		.loc 1 105 0
 206 0014 7B68     		ldr	r3, [r7, #4]
 207 0016 022B     		cmp	r3, #2
 208 0018 05D0     		beq	.L11
 106:.\uart_helper_fcns.c ****         UART_for_USB_PutString("Error! incorrect data. Did you type a number after a (p or d), a co
 209              		.loc 1 106 0
 210 001a 2848     		ldr	r0, .L17+16
 211 001c FFF7FEFF 		bl	UART_for_USB_PutString
 107:.\uart_helper_fcns.c ****         data = 0;
 212              		.loc 1 107 0
 213 0020 254B     		ldr	r3, .L17+12
 214 0022 0022     		movs	r2, #0
 215 0024 1A80     		strh	r2, [r3]	@ movhi
 216              	.L11:
 108:.\uart_helper_fcns.c ****     }
 109:.\uart_helper_fcns.c ****     
 110:.\uart_helper_fcns.c ****     // Depending on the mode, write either the period or the duty cycle:
 111:.\uart_helper_fcns.c ****     switch( mode )
 217              		.loc 1 111 0
 218 0026 234B     		ldr	r3, .L17+8
 219 0028 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 220 002a 642B     		cmp	r3, #100
 221 002c 11D0     		beq	.L13
 222 002e 702B     		cmp	r3, #112
 223 0030 1FD1     		bne	.L16
 224              	.LBB2:
 112:.\uart_helper_fcns.c ****     {
 113:.\uart_helper_fcns.c ****         case 'p':
 114:.\uart_helper_fcns.c ****         {
 115:.\uart_helper_fcns.c ****             /**
 116:.\uart_helper_fcns.c ****              * TUTORIAL 8, CODING TASK 2:
 117:.\uart_helper_fcns.c ****              * Write the period of the PWM.
 118:.\uart_helper_fcns.c ****              * At this point in the code, the variable "data" will store your PWM period as a uint1
 119:.\uart_helper_fcns.c ****              * hint: look at the API for the PWM component... something about writing and period.
 120:.\uart_helper_fcns.c ****              */
 121:.\uart_helper_fcns.c ****         
 122:.\uart_helper_fcns.c ****             ///////////////// PUT YOUR CODE HERE
 123:.\uart_helper_fcns.c ****             PWM_Servo_WritePeriod( data );
 225              		.loc 1 123 0
 226 0032 214B     		ldr	r3, .L17+12
 227 0034 1B88     		ldrh	r3, [r3]
 228 0036 1846     		mov	r0, r3
 229 0038 FFF7FEFF 		bl	PWM_Servo_WritePeriod
 124:.\uart_helper_fcns.c ****         
 125:.\uart_helper_fcns.c ****             // send back the data that was just written, for confirmation:
 126:.\uart_helper_fcns.c ****             // read back from the PWM, and send a message with the period inserted into the string
 127:.\uart_helper_fcns.c ****             uint16 period_written = PWM_Servo_ReadPeriod();
 230              		.loc 1 127 0
 231 003c FFF7FEFF 		bl	PWM_Servo_ReadPeriod
 232 0040 0346     		mov	r3, r0
 233 0042 7B80     		strh	r3, [r7, #2]	@ movhi
 128:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "PWM now has a period of: %i \r\n", period_written);
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 8


 234              		.loc 1 128 0
 235 0044 7B88     		ldrh	r3, [r7, #2]
 236 0046 1E48     		ldr	r0, .L17+20
 237 0048 1E49     		ldr	r1, .L17+24
 238 004a 1A46     		mov	r2, r3
 239 004c FFF7FEFF 		bl	sprintf
 129:.\uart_helper_fcns.c ****             break;
 240              		.loc 1 129 0
 241 0050 1DE0     		b	.L15
 242              	.L13:
 243              	.LBE2:
 244              	.LBB3:
 130:.\uart_helper_fcns.c ****         }
 131:.\uart_helper_fcns.c ****         case 'd':
 132:.\uart_helper_fcns.c ****         {
 133:.\uart_helper_fcns.c ****             /**
 134:.\uart_helper_fcns.c ****              * TUTORIAL 8, CODING TASK 3:
 135:.\uart_helper_fcns.c ****              * Write the duty cycle of the PWM. This is also called the "compare" value.
 136:.\uart_helper_fcns.c ****              * At this point in the code, the variable "data" will store your PWM duty cycle as a u
 137:.\uart_helper_fcns.c ****              * hint: look at the API for the PWM component... something about writing and compare v
 138:.\uart_helper_fcns.c ****              */
 139:.\uart_helper_fcns.c ****             
 140:.\uart_helper_fcns.c ****             ///////////////// PUT YOUR CODE HERE
 141:.\uart_helper_fcns.c ****             PWM_Servo_WriteCompare( data);
 245              		.loc 1 141 0
 246 0052 194B     		ldr	r3, .L17+12
 247 0054 1B88     		ldrh	r3, [r3]
 248 0056 1846     		mov	r0, r3
 249 0058 FFF7FEFF 		bl	PWM_Servo_WriteCompare
 142:.\uart_helper_fcns.c ****             
 143:.\uart_helper_fcns.c ****             // as with the period, send back what we just did:
 144:.\uart_helper_fcns.c ****             uint16 duty_written = PWM_Servo_ReadCompare();
 250              		.loc 1 144 0
 251 005c FFF7FEFF 		bl	PWM_Servo_ReadCompare
 252 0060 0346     		mov	r3, r0
 253 0062 3B80     		strh	r3, [r7]	@ movhi
 145:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "PWM now has a duty cycle (in clock ticks) of: %i \r\n", duty
 254              		.loc 1 145 0
 255 0064 3B88     		ldrh	r3, [r7]
 256 0066 1648     		ldr	r0, .L17+20
 257 0068 1749     		ldr	r1, .L17+28
 258 006a 1A46     		mov	r2, r3
 259 006c FFF7FEFF 		bl	sprintf
 146:.\uart_helper_fcns.c ****             break;
 260              		.loc 1 146 0
 261 0070 0DE0     		b	.L15
 262              	.L16:
 263              	.LBE3:
 147:.\uart_helper_fcns.c ****         }
 148:.\uart_helper_fcns.c ****         default:
 149:.\uart_helper_fcns.c ****         {
 150:.\uart_helper_fcns.c ****             // Print an error message if any other character besides a p or d was typed
 151:.\uart_helper_fcns.c ****             sprintf( transmit_buffer, "Error! You didn't type a p or d. \r\n");
 264              		.loc 1 151 0
 265 0072 134A     		ldr	r2, .L17+20
 266 0074 154B     		ldr	r3, .L17+32
 267 0076 1446     		mov	r4, r2
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 9


 268 0078 1D46     		mov	r5, r3
 269 007a 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 270 007c 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 271 007e 0FCD     		ldmia	r5!, {r0, r1, r2, r3}
 272 0080 0FC4     		stmia	r4!, {r0, r1, r2, r3}
 273 0082 2B68     		ldr	r3, [r5]
 274 0084 2360     		str	r3, [r4]
 152:.\uart_helper_fcns.c ****             // just in case
 153:.\uart_helper_fcns.c ****             mode = 0;
 275              		.loc 1 153 0
 276 0086 0B4B     		ldr	r3, .L17+8
 277 0088 0022     		movs	r2, #0
 278 008a 1A70     		strb	r2, [r3]
 154:.\uart_helper_fcns.c ****             break;
 279              		.loc 1 154 0
 280 008c 00BF     		nop
 281              	.L15:
 155:.\uart_helper_fcns.c ****         }
 156:.\uart_helper_fcns.c ****     } 
 157:.\uart_helper_fcns.c ****     
 158:.\uart_helper_fcns.c ****     // send the byte back to your PC so you know what you set
 159:.\uart_helper_fcns.c ****     UART_for_USB_PutString( transmit_buffer );    
 282              		.loc 1 159 0
 283 008e 0C48     		ldr	r0, .L17+20
 284 0090 FFF7FEFF 		bl	UART_for_USB_PutString
 160:.\uart_helper_fcns.c ****     // to make this easier to read, send another newline.
 161:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
 285              		.loc 1 161 0
 286 0094 0E48     		ldr	r0, .L17+36
 287 0096 FFF7FEFF 		bl	UART_for_USB_PutString
 162:.\uart_helper_fcns.c ****     // Reset the indexing into the array
 163:.\uart_helper_fcns.c ****     num_chars_received = 0;
 288              		.loc 1 163 0
 289 009a 0E4B     		ldr	r3, .L17+40
 290 009c 0022     		movs	r2, #0
 291 009e 1A70     		strb	r2, [r3]
 164:.\uart_helper_fcns.c ****     // and just in case let's do the data too.
 165:.\uart_helper_fcns.c ****     data = 0;
 292              		.loc 1 165 0
 293 00a0 054B     		ldr	r3, .L17+12
 294 00a2 0022     		movs	r2, #0
 295 00a4 1A80     		strh	r2, [r3]	@ movhi
 166:.\uart_helper_fcns.c ****     // Note that we don't have to reset the buffer here, since sscanf only reads up until the first
 167:.\uart_helper_fcns.c **** }
 296              		.loc 1 167 0
 297 00a6 0837     		adds	r7, r7, #8
 298 00a8 BD46     		mov	sp, r7
 299              		@ sp needed
 300 00aa B0BD     		pop	{r4, r5, r7, pc}
 301              	.L18:
 302              		.align	2
 303              	.L17:
 304 00ac 80000000 		.word	receive_buffer
 305 00b0 2C000000 		.word	.LC3
 306 00b4 04010000 		.word	mode
 307 00b8 02010000 		.word	data
 308 00bc 38000000 		.word	.LC4
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 10


 309 00c0 00000000 		.word	transmit_buffer
 310 00c4 9C000000 		.word	.LC5
 311 00c8 BC000000 		.word	.LC6
 312 00cc F0000000 		.word	.LC7
 313 00d0 00000000 		.word	.LC0
 314 00d4 00010000 		.word	num_chars_received
 315              		.cfi_endproc
 316              	.LFE57:
 317              		.size	Write_PWM_and_UART, .-Write_PWM_and_UART
 318              		.text
 319              	.Letext0:
 320              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
 321              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
 322              		.file 4 ".\\Generated_Source\\PSoC5/cytypes.h"
 323              		.file 5 ".\\Generated_Source\\PSoC5/core_cm3.h"
 324              		.section	.debug_info,"",%progbits
 325              	.Ldebug_info0:
 326 0000 A2010000 		.4byte	0x1a2
 327 0004 0400     		.2byte	0x4
 328 0006 00000000 		.4byte	.Ldebug_abbrev0
 329 000a 04       		.byte	0x4
 330 000b 01       		.uleb128 0x1
 331 000c 5E000000 		.4byte	.LASF26
 332 0010 01       		.byte	0x1
 333 0011 38020000 		.4byte	.LASF27
 334 0015 C0010000 		.4byte	.LASF28
 335 0019 00000000 		.4byte	.Ldebug_ranges0+0
 336 001d 00000000 		.4byte	0
 337 0021 00000000 		.4byte	.Ldebug_line0
 338 0025 02       		.uleb128 0x2
 339 0026 01       		.byte	0x1
 340 0027 06       		.byte	0x6
 341 0028 24000000 		.4byte	.LASF0
 342 002c 02       		.uleb128 0x2
 343 002d 01       		.byte	0x1
 344 002e 08       		.byte	0x8
 345 002f 3D000000 		.4byte	.LASF1
 346 0033 02       		.uleb128 0x2
 347 0034 02       		.byte	0x2
 348 0035 05       		.byte	0x5
 349 0036 1F020000 		.4byte	.LASF2
 350 003a 02       		.uleb128 0x2
 351 003b 02       		.byte	0x2
 352 003c 07       		.byte	0x7
 353 003d EC000000 		.4byte	.LASF3
 354 0041 03       		.uleb128 0x3
 355 0042 00000000 		.4byte	.LASF9
 356 0046 02       		.byte	0x2
 357 0047 37       		.byte	0x37
 358 0048 4C000000 		.4byte	0x4c
 359 004c 02       		.uleb128 0x2
 360 004d 04       		.byte	0x4
 361 004e 05       		.byte	0x5
 362 004f 2F020000 		.4byte	.LASF4
 363 0053 02       		.uleb128 0x2
 364 0054 04       		.byte	0x4
 365 0055 07       		.byte	0x7
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 11


 366 0056 DA000000 		.4byte	.LASF5
 367 005a 02       		.uleb128 0x2
 368 005b 08       		.byte	0x8
 369 005c 05       		.byte	0x5
 370 005d B2010000 		.4byte	.LASF6
 371 0061 02       		.uleb128 0x2
 372 0062 08       		.byte	0x8
 373 0063 07       		.byte	0x7
 374 0064 68010000 		.4byte	.LASF7
 375 0068 04       		.uleb128 0x4
 376 0069 04       		.byte	0x4
 377 006a 05       		.byte	0x5
 378 006b 696E7400 		.ascii	"int\000"
 379 006f 02       		.uleb128 0x2
 380 0070 04       		.byte	0x4
 381 0071 07       		.byte	0x7
 382 0072 5B010000 		.4byte	.LASF8
 383 0076 03       		.uleb128 0x3
 384 0077 A1010000 		.4byte	.LASF10
 385 007b 03       		.byte	0x3
 386 007c 41       		.byte	0x41
 387 007d 41000000 		.4byte	0x41
 388 0081 03       		.uleb128 0x3
 389 0082 29020000 		.4byte	.LASF11
 390 0086 04       		.byte	0x4
 391 0087 A1       		.byte	0xa1
 392 0088 2C000000 		.4byte	0x2c
 393 008c 03       		.uleb128 0x3
 394 008d 54010000 		.4byte	.LASF12
 395 0091 04       		.byte	0x4
 396 0092 A2       		.byte	0xa2
 397 0093 3A000000 		.4byte	0x3a
 398 0097 02       		.uleb128 0x2
 399 0098 04       		.byte	0x4
 400 0099 04       		.byte	0x4
 401 009a 19000000 		.4byte	.LASF13
 402 009e 02       		.uleb128 0x2
 403 009f 08       		.byte	0x8
 404 00a0 04       		.byte	0x4
 405 00a1 4D010000 		.4byte	.LASF14
 406 00a5 02       		.uleb128 0x2
 407 00a6 01       		.byte	0x1
 408 00a7 08       		.byte	0x8
 409 00a8 1A020000 		.4byte	.LASF15
 410 00ac 02       		.uleb128 0x2
 411 00ad 04       		.byte	0x4
 412 00ae 07       		.byte	0x7
 413 00af A9010000 		.4byte	.LASF16
 414 00b3 05       		.uleb128 0x5
 415 00b4 1B010000 		.4byte	.LASF29
 416 00b8 01       		.byte	0x1
 417 00b9 2C       		.byte	0x2c
 418 00ba 00000000 		.4byte	.LFB56
 419 00be 9C000000 		.4byte	.LFE56-.LFB56
 420 00c2 01       		.uleb128 0x1
 421 00c3 9C       		.byte	0x9c
 422 00c4 D7000000 		.4byte	0xd7
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 12


 423 00c8 06       		.uleb128 0x6
 424 00c9 93010000 		.4byte	.LASF17
 425 00cd 01       		.byte	0x1
 426 00ce 2E       		.byte	0x2e
 427 00cf 81000000 		.4byte	0x81
 428 00d3 02       		.uleb128 0x2
 429 00d4 91       		.byte	0x91
 430 00d5 77       		.sleb128 -9
 431 00d6 00       		.byte	0
 432 00d7 07       		.uleb128 0x7
 433 00d8 4B000000 		.4byte	.LASF30
 434 00dc 01       		.byte	0x1
 435 00dd 5F       		.byte	0x5f
 436 00de 00000000 		.4byte	.LFB57
 437 00e2 D8000000 		.4byte	.LFE57-.LFB57
 438 00e6 01       		.uleb128 0x1
 439 00e7 9C       		.byte	0x9c
 440 00e8 2F010000 		.4byte	0x12f
 441 00ec 06       		.uleb128 0x6
 442 00ed 84010000 		.4byte	.LASF18
 443 00f1 01       		.byte	0x1
 444 00f2 64       		.byte	0x64
 445 00f3 68000000 		.4byte	0x68
 446 00f7 02       		.uleb128 0x2
 447 00f8 91       		.byte	0x91
 448 00f9 6C       		.sleb128 -20
 449 00fa 08       		.uleb128 0x8
 450 00fb 32000000 		.4byte	.LBB2
 451 00ff 20000000 		.4byte	.LBE2-.LBB2
 452 0103 16010000 		.4byte	0x116
 453 0107 06       		.uleb128 0x6
 454 0108 0A000000 		.4byte	.LASF19
 455 010c 01       		.byte	0x1
 456 010d 7F       		.byte	0x7f
 457 010e 8C000000 		.4byte	0x8c
 458 0112 02       		.uleb128 0x2
 459 0113 91       		.byte	0x91
 460 0114 6A       		.sleb128 -22
 461 0115 00       		.byte	0
 462 0116 09       		.uleb128 0x9
 463 0117 52000000 		.4byte	.LBB3
 464 011b 20000000 		.4byte	.LBE3-.LBB3
 465 011f 06       		.uleb128 0x6
 466 0120 30000000 		.4byte	.LASF20
 467 0124 01       		.byte	0x1
 468 0125 90       		.byte	0x90
 469 0126 8C000000 		.4byte	0x8c
 470 012a 02       		.uleb128 0x2
 471 012b 91       		.byte	0x91
 472 012c 68       		.sleb128 -24
 473 012d 00       		.byte	0
 474 012e 00       		.byte	0
 475 012f 0A       		.uleb128 0xa
 476 0130 A5000000 		.4byte	0xa5
 477 0134 3F010000 		.4byte	0x13f
 478 0138 0B       		.uleb128 0xb
 479 0139 AC000000 		.4byte	0xac
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 13


 480 013d 7F       		.byte	0x7f
 481 013e 00       		.byte	0
 482 013f 06       		.uleb128 0x6
 483 0140 4D020000 		.4byte	.LASF21
 484 0144 01       		.byte	0x1
 485 0145 17       		.byte	0x17
 486 0146 2F010000 		.4byte	0x12f
 487 014a 05       		.uleb128 0x5
 488 014b 03       		.byte	0x3
 489 014c 00000000 		.4byte	transmit_buffer
 490 0150 06       		.uleb128 0x6
 491 0151 FF000000 		.4byte	.LASF22
 492 0155 01       		.byte	0x1
 493 0156 18       		.byte	0x18
 494 0157 2F010000 		.4byte	0x12f
 495 015b 05       		.uleb128 0x5
 496 015c 03       		.byte	0x3
 497 015d 80000000 		.4byte	receive_buffer
 498 0161 06       		.uleb128 0x6
 499 0162 3A010000 		.4byte	.LASF23
 500 0166 01       		.byte	0x1
 501 0167 1C       		.byte	0x1c
 502 0168 81000000 		.4byte	0x81
 503 016c 05       		.uleb128 0x5
 504 016d 03       		.byte	0x3
 505 016e 00010000 		.4byte	num_chars_received
 506 0172 06       		.uleb128 0x6
 507 0173 1F000000 		.4byte	.LASF24
 508 0177 01       		.byte	0x1
 509 0178 20       		.byte	0x20
 510 0179 8C000000 		.4byte	0x8c
 511 017d 05       		.uleb128 0x5
 512 017e 03       		.byte	0x3
 513 017f 02010000 		.4byte	data
 514 0183 06       		.uleb128 0x6
 515 0184 7F010000 		.4byte	.LASF25
 516 0188 01       		.byte	0x1
 517 0189 23       		.byte	0x23
 518 018a A5000000 		.4byte	0xa5
 519 018e 05       		.uleb128 0x5
 520 018f 03       		.byte	0x3
 521 0190 04010000 		.4byte	mode
 522 0194 0C       		.uleb128 0xc
 523 0195 0E010000 		.4byte	.LASF31
 524 0199 05       		.byte	0x5
 525 019a 1606     		.2byte	0x616
 526 019c A0010000 		.4byte	0x1a0
 527 01a0 0D       		.uleb128 0xd
 528 01a1 76000000 		.4byte	0x76
 529 01a5 00       		.byte	0
 530              		.section	.debug_abbrev,"",%progbits
 531              	.Ldebug_abbrev0:
 532 0000 01       		.uleb128 0x1
 533 0001 11       		.uleb128 0x11
 534 0002 01       		.byte	0x1
 535 0003 25       		.uleb128 0x25
 536 0004 0E       		.uleb128 0xe
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 14


 537 0005 13       		.uleb128 0x13
 538 0006 0B       		.uleb128 0xb
 539 0007 03       		.uleb128 0x3
 540 0008 0E       		.uleb128 0xe
 541 0009 1B       		.uleb128 0x1b
 542 000a 0E       		.uleb128 0xe
 543 000b 55       		.uleb128 0x55
 544 000c 17       		.uleb128 0x17
 545 000d 11       		.uleb128 0x11
 546 000e 01       		.uleb128 0x1
 547 000f 10       		.uleb128 0x10
 548 0010 17       		.uleb128 0x17
 549 0011 00       		.byte	0
 550 0012 00       		.byte	0
 551 0013 02       		.uleb128 0x2
 552 0014 24       		.uleb128 0x24
 553 0015 00       		.byte	0
 554 0016 0B       		.uleb128 0xb
 555 0017 0B       		.uleb128 0xb
 556 0018 3E       		.uleb128 0x3e
 557 0019 0B       		.uleb128 0xb
 558 001a 03       		.uleb128 0x3
 559 001b 0E       		.uleb128 0xe
 560 001c 00       		.byte	0
 561 001d 00       		.byte	0
 562 001e 03       		.uleb128 0x3
 563 001f 16       		.uleb128 0x16
 564 0020 00       		.byte	0
 565 0021 03       		.uleb128 0x3
 566 0022 0E       		.uleb128 0xe
 567 0023 3A       		.uleb128 0x3a
 568 0024 0B       		.uleb128 0xb
 569 0025 3B       		.uleb128 0x3b
 570 0026 0B       		.uleb128 0xb
 571 0027 49       		.uleb128 0x49
 572 0028 13       		.uleb128 0x13
 573 0029 00       		.byte	0
 574 002a 00       		.byte	0
 575 002b 04       		.uleb128 0x4
 576 002c 24       		.uleb128 0x24
 577 002d 00       		.byte	0
 578 002e 0B       		.uleb128 0xb
 579 002f 0B       		.uleb128 0xb
 580 0030 3E       		.uleb128 0x3e
 581 0031 0B       		.uleb128 0xb
 582 0032 03       		.uleb128 0x3
 583 0033 08       		.uleb128 0x8
 584 0034 00       		.byte	0
 585 0035 00       		.byte	0
 586 0036 05       		.uleb128 0x5
 587 0037 2E       		.uleb128 0x2e
 588 0038 01       		.byte	0x1
 589 0039 3F       		.uleb128 0x3f
 590 003a 19       		.uleb128 0x19
 591 003b 03       		.uleb128 0x3
 592 003c 0E       		.uleb128 0xe
 593 003d 3A       		.uleb128 0x3a
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 15


 594 003e 0B       		.uleb128 0xb
 595 003f 3B       		.uleb128 0x3b
 596 0040 0B       		.uleb128 0xb
 597 0041 27       		.uleb128 0x27
 598 0042 19       		.uleb128 0x19
 599 0043 11       		.uleb128 0x11
 600 0044 01       		.uleb128 0x1
 601 0045 12       		.uleb128 0x12
 602 0046 06       		.uleb128 0x6
 603 0047 40       		.uleb128 0x40
 604 0048 18       		.uleb128 0x18
 605 0049 9642     		.uleb128 0x2116
 606 004b 19       		.uleb128 0x19
 607 004c 01       		.uleb128 0x1
 608 004d 13       		.uleb128 0x13
 609 004e 00       		.byte	0
 610 004f 00       		.byte	0
 611 0050 06       		.uleb128 0x6
 612 0051 34       		.uleb128 0x34
 613 0052 00       		.byte	0
 614 0053 03       		.uleb128 0x3
 615 0054 0E       		.uleb128 0xe
 616 0055 3A       		.uleb128 0x3a
 617 0056 0B       		.uleb128 0xb
 618 0057 3B       		.uleb128 0x3b
 619 0058 0B       		.uleb128 0xb
 620 0059 49       		.uleb128 0x49
 621 005a 13       		.uleb128 0x13
 622 005b 02       		.uleb128 0x2
 623 005c 18       		.uleb128 0x18
 624 005d 00       		.byte	0
 625 005e 00       		.byte	0
 626 005f 07       		.uleb128 0x7
 627 0060 2E       		.uleb128 0x2e
 628 0061 01       		.byte	0x1
 629 0062 3F       		.uleb128 0x3f
 630 0063 19       		.uleb128 0x19
 631 0064 03       		.uleb128 0x3
 632 0065 0E       		.uleb128 0xe
 633 0066 3A       		.uleb128 0x3a
 634 0067 0B       		.uleb128 0xb
 635 0068 3B       		.uleb128 0x3b
 636 0069 0B       		.uleb128 0xb
 637 006a 11       		.uleb128 0x11
 638 006b 01       		.uleb128 0x1
 639 006c 12       		.uleb128 0x12
 640 006d 06       		.uleb128 0x6
 641 006e 40       		.uleb128 0x40
 642 006f 18       		.uleb128 0x18
 643 0070 9642     		.uleb128 0x2116
 644 0072 19       		.uleb128 0x19
 645 0073 01       		.uleb128 0x1
 646 0074 13       		.uleb128 0x13
 647 0075 00       		.byte	0
 648 0076 00       		.byte	0
 649 0077 08       		.uleb128 0x8
 650 0078 0B       		.uleb128 0xb
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 16


 651 0079 01       		.byte	0x1
 652 007a 11       		.uleb128 0x11
 653 007b 01       		.uleb128 0x1
 654 007c 12       		.uleb128 0x12
 655 007d 06       		.uleb128 0x6
 656 007e 01       		.uleb128 0x1
 657 007f 13       		.uleb128 0x13
 658 0080 00       		.byte	0
 659 0081 00       		.byte	0
 660 0082 09       		.uleb128 0x9
 661 0083 0B       		.uleb128 0xb
 662 0084 01       		.byte	0x1
 663 0085 11       		.uleb128 0x11
 664 0086 01       		.uleb128 0x1
 665 0087 12       		.uleb128 0x12
 666 0088 06       		.uleb128 0x6
 667 0089 00       		.byte	0
 668 008a 00       		.byte	0
 669 008b 0A       		.uleb128 0xa
 670 008c 01       		.uleb128 0x1
 671 008d 01       		.byte	0x1
 672 008e 49       		.uleb128 0x49
 673 008f 13       		.uleb128 0x13
 674 0090 01       		.uleb128 0x1
 675 0091 13       		.uleb128 0x13
 676 0092 00       		.byte	0
 677 0093 00       		.byte	0
 678 0094 0B       		.uleb128 0xb
 679 0095 21       		.uleb128 0x21
 680 0096 00       		.byte	0
 681 0097 49       		.uleb128 0x49
 682 0098 13       		.uleb128 0x13
 683 0099 2F       		.uleb128 0x2f
 684 009a 0B       		.uleb128 0xb
 685 009b 00       		.byte	0
 686 009c 00       		.byte	0
 687 009d 0C       		.uleb128 0xc
 688 009e 34       		.uleb128 0x34
 689 009f 00       		.byte	0
 690 00a0 03       		.uleb128 0x3
 691 00a1 0E       		.uleb128 0xe
 692 00a2 3A       		.uleb128 0x3a
 693 00a3 0B       		.uleb128 0xb
 694 00a4 3B       		.uleb128 0x3b
 695 00a5 05       		.uleb128 0x5
 696 00a6 49       		.uleb128 0x49
 697 00a7 13       		.uleb128 0x13
 698 00a8 3F       		.uleb128 0x3f
 699 00a9 19       		.uleb128 0x19
 700 00aa 3C       		.uleb128 0x3c
 701 00ab 19       		.uleb128 0x19
 702 00ac 00       		.byte	0
 703 00ad 00       		.byte	0
 704 00ae 0D       		.uleb128 0xd
 705 00af 35       		.uleb128 0x35
 706 00b0 00       		.byte	0
 707 00b1 49       		.uleb128 0x49
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 17


 708 00b2 13       		.uleb128 0x13
 709 00b3 00       		.byte	0
 710 00b4 00       		.byte	0
 711 00b5 00       		.byte	0
 712              		.section	.debug_aranges,"",%progbits
 713 0000 24000000 		.4byte	0x24
 714 0004 0200     		.2byte	0x2
 715 0006 00000000 		.4byte	.Ldebug_info0
 716 000a 04       		.byte	0x4
 717 000b 00       		.byte	0
 718 000c 0000     		.2byte	0
 719 000e 0000     		.2byte	0
 720 0010 00000000 		.4byte	.LFB56
 721 0014 9C000000 		.4byte	.LFE56-.LFB56
 722 0018 00000000 		.4byte	.LFB57
 723 001c D8000000 		.4byte	.LFE57-.LFB57
 724 0020 00000000 		.4byte	0
 725 0024 00000000 		.4byte	0
 726              		.section	.debug_ranges,"",%progbits
 727              	.Ldebug_ranges0:
 728 0000 00000000 		.4byte	.LFB56
 729 0004 9C000000 		.4byte	.LFE56
 730 0008 00000000 		.4byte	.LFB57
 731 000c D8000000 		.4byte	.LFE57
 732 0010 00000000 		.4byte	0
 733 0014 00000000 		.4byte	0
 734              		.section	.debug_line,"",%progbits
 735              	.Ldebug_line0:
 736 0000 AE010000 		.section	.debug_str,"MS",%progbits,1
 736      02005D01 
 736      00000201 
 736      FB0E0D00 
 736      01010101 
 737              	.LASF9:
 738 0000 5F5F696E 		.ascii	"__int32_t\000"
 738      7433325F 
 738      7400
 739              	.LASF19:
 740 000a 70657269 		.ascii	"period_written\000"
 740      6F645F77 
 740      72697474 
 740      656E00
 741              	.LASF13:
 742 0019 666C6F61 		.ascii	"float\000"
 742      7400
 743              	.LASF24:
 744 001f 64617461 		.ascii	"data\000"
 744      00
 745              	.LASF0:
 746 0024 7369676E 		.ascii	"signed char\000"
 746      65642063 
 746      68617200 
 747              	.LASF20:
 748 0030 64757479 		.ascii	"duty_written\000"
 748      5F777269 
 748      7474656E 
 748      00
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 18


 749              	.LASF1:
 750 003d 756E7369 		.ascii	"unsigned char\000"
 750      676E6564 
 750      20636861 
 750      7200
 751              	.LASF30:
 752 004b 57726974 		.ascii	"Write_PWM_and_UART\000"
 752      655F5057 
 752      4D5F616E 
 752      645F5541 
 752      525400
 753              	.LASF26:
 754 005e 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 754      4320342E 
 754      382E3420 
 754      32303134 
 754      30353236 
 755 0091 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m3 -mthumb -g -O"
 755      20726576 
 755      6973696F 
 755      6E203231 
 755      31333538 
 756 00c4 30202D66 		.ascii	"0 -ffunction-sections\000"
 756      66756E63 
 756      74696F6E 
 756      2D736563 
 756      74696F6E 
 757              	.LASF5:
 758 00da 6C6F6E67 		.ascii	"long unsigned int\000"
 758      20756E73 
 758      69676E65 
 758      6420696E 
 758      7400
 759              	.LASF3:
 760 00ec 73686F72 		.ascii	"short unsigned int\000"
 760      7420756E 
 760      7369676E 
 760      65642069 
 760      6E7400
 761              	.LASF22:
 762 00ff 72656365 		.ascii	"receive_buffer\000"
 762      6976655F 
 762      62756666 
 762      657200
 763              	.LASF31:
 764 010e 49544D5F 		.ascii	"ITM_RxBuffer\000"
 764      52784275 
 764      66666572 
 764      00
 765              	.LASF29:
 766 011b 496E7465 		.ascii	"Interrupt_Handler_UART_Receive\000"
 766      72727570 
 766      745F4861 
 766      6E646C65 
 766      725F5541 
 767              	.LASF23:
 768 013a 6E756D5F 		.ascii	"num_chars_received\000"
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 19


 768      63686172 
 768      735F7265 
 768      63656976 
 768      656400
 769              	.LASF14:
 770 014d 646F7562 		.ascii	"double\000"
 770      6C6500
 771              	.LASF12:
 772 0154 75696E74 		.ascii	"uint16\000"
 772      313600
 773              	.LASF8:
 774 015b 756E7369 		.ascii	"unsigned int\000"
 774      676E6564 
 774      20696E74 
 774      00
 775              	.LASF7:
 776 0168 6C6F6E67 		.ascii	"long long unsigned int\000"
 776      206C6F6E 
 776      6720756E 
 776      7369676E 
 776      65642069 
 777              	.LASF25:
 778 017f 6D6F6465 		.ascii	"mode\000"
 778      00
 779              	.LASF18:
 780 0184 6E756D5F 		.ascii	"num_var_filled\000"
 780      7661725F 
 780      66696C6C 
 780      656400
 781              	.LASF17:
 782 0193 72656365 		.ascii	"received_byte\000"
 782      69766564 
 782      5F627974 
 782      6500
 783              	.LASF10:
 784 01a1 696E7433 		.ascii	"int32_t\000"
 784      325F7400 
 785              	.LASF16:
 786 01a9 73697A65 		.ascii	"sizetype\000"
 786      74797065 
 786      00
 787              	.LASF6:
 788 01b2 6C6F6E67 		.ascii	"long long int\000"
 788      206C6F6E 
 788      6720696E 
 788      7400
 789              	.LASF28:
 790 01c0 443A5C73 		.ascii	"D:\\synct\\Teaching\\ME 135 S18\\Tutorials\\T8\\ske"
 790      796E6374 
 790      5C546561 
 790      6368696E 
 790      675C4D45 
 791 01ed 6C65746F 		.ascii	"leton_code\\me235\\PWM_UART_Multitasking.cydsn\000"
 791      6E5F636F 
 791      64655C6D 
 791      65323335 
 791      5C50574D 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccRbQrNh.s 			page 20


 792              	.LASF15:
 793 021a 63686172 		.ascii	"char\000"
 793      00
 794              	.LASF2:
 795 021f 73686F72 		.ascii	"short int\000"
 795      7420696E 
 795      7400
 796              	.LASF11:
 797 0229 75696E74 		.ascii	"uint8\000"
 797      3800
 798              	.LASF4:
 799 022f 6C6F6E67 		.ascii	"long int\000"
 799      20696E74 
 799      00
 800              	.LASF27:
 801 0238 2E5C7561 		.ascii	".\\uart_helper_fcns.c\000"
 801      72745F68 
 801      656C7065 
 801      725F6663 
 801      6E732E63 
 802              	.LASF21:
 803 024d 7472616E 		.ascii	"transmit_buffer\000"
 803      736D6974 
 803      5F627566 
 803      66657200 
 804              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
