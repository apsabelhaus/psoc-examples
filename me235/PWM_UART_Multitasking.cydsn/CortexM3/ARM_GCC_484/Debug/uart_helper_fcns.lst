ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 1


   1              		.syntax unified
   2              		.cpu cortex-m3
   3              		.fpu softvfp
   4              		.eabi_attribute 20, 1
   5              		.eabi_attribute 21, 1
   6              		.eabi_attribute 23, 3
   7              		.eabi_attribute 24, 1
   8              		.eabi_attribute 25, 1
   9              		.eabi_attribute 26, 1
  10              		.eabi_attribute 30, 6
  11              		.eabi_attribute 34, 1
  12              		.eabi_attribute 18, 4
  13              		.thumb
  14              		.file	"uart_helper_fcns.c"
  15              		.text
  16              	.Ltext0:
  17              		.cfi_sections	.debug_frame
  18              		.bss
  19              		.align	2
  20              	transmit_buffer:
  21 0000 00000000 		.space	128
  21      00000000 
  21      00000000 
  21      00000000 
  21      00000000 
  22              		.align	2
  23              	receive_buffer:
  24 0080 00000000 		.space	128
  24      00000000 
  24      00000000 
  24      00000000 
  24      00000000 
  25              	num_chars_received:
  26 0100 00       		.space	1
  27 0101 00       		.align	1
  28              	period:
  29 0102 0000     		.space	2
  30              		.section	.rodata
  31              		.align	2
  32              	.LC0:
  33 0000 53746F70 		.ascii	"Stopping PWM.\015\012\000"
  33      70696E67 
  33      2050574D 
  33      2E0D0A00 
  34              		.align	2
  35              	.LC1:
  36 0010 52657374 		.ascii	"Restarting PWM.\015\012\000"
  36      61727469 
  36      6E672050 
  36      574D2E0D 
  36      0A00
  37              		.section	.text.Interrupt_Handler_UART_Receive,"ax",%progbits
  38              		.align	2
  39              		.global	Interrupt_Handler_UART_Receive
  40              		.thumb
  41              		.thumb_func
  42              		.type	Interrupt_Handler_UART_Receive, %function
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 2


  43              	Interrupt_Handler_UART_Receive:
  44              	.LFB56:
  45              		.file 1 ".\\uart_helper_fcns.c"
   1:.\uart_helper_fcns.c **** /* ========================================
   2:.\uart_helper_fcns.c ****  *
   3:.\uart_helper_fcns.c ****  * Copyright Andrew P. Sabelhaus, 2018 
   4:.\uart_helper_fcns.c ****  * See README and LICENSE for more details.
   5:.\uart_helper_fcns.c ****  *
   6:.\uart_helper_fcns.c ****  * ========================================
   7:.\uart_helper_fcns.c **** */
   8:.\uart_helper_fcns.c **** 
   9:.\uart_helper_fcns.c **** // Code adapted heavily from Cypress' example CE95277 ADC and UART,
  10:.\uart_helper_fcns.c **** // but all re-written by Drew.
  11:.\uart_helper_fcns.c **** 
  12:.\uart_helper_fcns.c **** // We wrote the declarations in the header file,
  13:.\uart_helper_fcns.c **** // and define them here.
  14:.\uart_helper_fcns.c **** // Including this header file in both main.c and here will allow the functions
  15:.\uart_helper_fcns.c **** // to be accessible both places (one to define them, one to use them).
  16:.\uart_helper_fcns.c **** 
  17:.\uart_helper_fcns.c **** // Unlike in the header files, we don't need to add include guards here.
  18:.\uart_helper_fcns.c **** // That's because the guards are already present in the .h files themselves.
  19:.\uart_helper_fcns.c **** #include "uart_helper_fcns.h"
  20:.\uart_helper_fcns.c **** #include <project.h>
  21:.\uart_helper_fcns.c **** // stdio.h provides the sprintf and sscanf functions for working with strings.
  22:.\uart_helper_fcns.c **** #include "stdio.h"
  23:.\uart_helper_fcns.c **** 
  24:.\uart_helper_fcns.c **** // We're going to define the size of the character array for the transmission
  25:.\uart_helper_fcns.c **** // back to the PC. This is in bytes: if a uint8 is one character, we can store
  26:.\uart_helper_fcns.c **** // a string of this length. E.g. 16 gives us 16 characters, including any integers represented as c
  27:.\uart_helper_fcns.c **** // This solves exactly the same problem as in the supplement to tutorial 6!!!
  28:.\uart_helper_fcns.c **** // Drew used 128 here, like with receive, because it's 
  29:.\uart_helper_fcns.c **** // "big enough." Compare to the size of the period of the PWM, as returned from ReadPeriod(), 
  30:.\uart_helper_fcns.c **** // and the string of text I put down below.
  31:.\uart_helper_fcns.c **** // How many bytes (characters) will we expect to need to send back? How many are "taken up" by the 
  32:.\uart_helper_fcns.c **** #define TRANSMIT_LENGTH 128
  33:.\uart_helper_fcns.c **** // We're also going to keep a buffer of received characters, since multiple bytes are needed.
  34:.\uart_helper_fcns.c **** // The size of this here is the number of characters you can type into TeraTerm before pressing ent
  35:.\uart_helper_fcns.c **** // George suggested 128, which is way many more than you'll need. 
  36:.\uart_helper_fcns.c **** // Note the example of "make the array larger than you need just in case because it doesn't really 
  37:.\uart_helper_fcns.c **** #define RECEIVE_LENGTH 128
  38:.\uart_helper_fcns.c **** 
  39:.\uart_helper_fcns.c **** // See tutorial 7 supplement for discussion on "static".
  40:.\uart_helper_fcns.c **** 
  41:.\uart_helper_fcns.c **** // Also, keep the buffer as a global variable instead of creating it inside the ISR.
  42:.\uart_helper_fcns.c **** // This is for efficiency, and since we'll need to send back a string of characters with numbers al
  43:.\uart_helper_fcns.c **** static char transmit_buffer[TRANSMIT_LENGTH];
  44:.\uart_helper_fcns.c **** // similarly, we want a receive buffer, for taking in multiple charactes as they are sent to the PS
  45:.\uart_helper_fcns.c **** static char receive_buffer[RECEIVE_LENGTH];
  46:.\uart_helper_fcns.c **** 
  47:.\uart_helper_fcns.c **** // Since the UART only sends single bytes, we encounter a problem with setting numerical values.
  48:.\uart_helper_fcns.c **** // Specifically, the byte send is interpreted as a character, NOT a number.
  49:.\uart_helper_fcns.c **** // See the ASCII table for a bit more intuition: for example, to set a period between 100 and 200, 
  50:.\uart_helper_fcns.c **** // type in the characters between 'd' and 'weird L bar thing that isn't on Drew's keyboard. 
  51:.\uart_helper_fcns.c **** // https://www.asciitable.com/
  52:.\uart_helper_fcns.c **** // That's not OK. Instead, let's take in each character, store it in a buffer.
  53:.\uart_helper_fcns.c **** // The num_chars_received integer allows us to index into the string buffer (since it's an array of
  54:.\uart_helper_fcns.c **** static uint8 num_chars_received = 0;
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 3


  55:.\uart_helper_fcns.c **** 
  56:.\uart_helper_fcns.c **** // In the example that Drew got from George, we used a character to split
  57:.\uart_helper_fcns.c **** 
  58:.\uart_helper_fcns.c **** // the period, as recorded in the helpers below. By declaring with global scope, we
  59:.\uart_helper_fcns.c **** // increase efficiency.
  60:.\uart_helper_fcns.c **** static uint16 period = 0;
  61:.\uart_helper_fcns.c **** 
  62:.\uart_helper_fcns.c **** // Definition of the UART ISR
  63:.\uart_helper_fcns.c **** // We use the same line for the function definition, with the CY_ISR macro.
  64:.\uart_helper_fcns.c **** // Compare this to tutorial 6, with "pythagorean"
  65:.\uart_helper_fcns.c **** CY_ISR( Interrupt_Handler_UART_Receive){
  46              		.loc 1 65 0
  47              		.cfi_startproc
  48              		@ args = 0, pretend = 0, frame = 8
  49              		@ frame_needed = 1, uses_anonymous_args = 0
  50 0000 80B5     		push	{r7, lr}
  51              		.cfi_def_cfa_offset 8
  52              		.cfi_offset 7, -8
  53              		.cfi_offset 14, -4
  54 0002 82B0     		sub	sp, sp, #8
  55              		.cfi_def_cfa_offset 16
  56 0004 00AF     		add	r7, sp, #0
  57              		.cfi_def_cfa_register 7
  66:.\uart_helper_fcns.c ****     // We assume this ISR is called when a byte is received.
  67:.\uart_helper_fcns.c ****     // See how the IDE doesn't give any errors, as long as we include project.h here.
  68:.\uart_helper_fcns.c ****     uint8 received_byte = UART_for_USB_GetChar();
  58              		.loc 1 68 0
  59 0006 FFF7FEFF 		bl	UART_for_USB_GetChar
  60 000a 0346     		mov	r3, r0
  61 000c FB71     		strb	r3, [r7, #7]
  69:.\uart_helper_fcns.c ****     
  70:.\uart_helper_fcns.c ****     //DEBUGGING
  71:.\uart_helper_fcns.c ****     /*
  72:.\uart_helper_fcns.c ****     UART_for_USB_PutString( "Received a character: ");
  73:.\uart_helper_fcns.c ****     UART_for_USB_PutChar( received_byte );
  74:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
  75:.\uart_helper_fcns.c ****     */
  76:.\uart_helper_fcns.c ****     
  77:.\uart_helper_fcns.c ****     // Next, we need to deal with what was received, in the following way.
  78:.\uart_helper_fcns.c ****     // If a new line is received (the \n character, or ASCII values 10 or 12 or 13 depending on if 
  79:.\uart_helper_fcns.c ****     // then finally set the period.
  80:.\uart_helper_fcns.c ****     // Otherwise, add to the uint16 we're keeping track of.
  81:.\uart_helper_fcns.c ****     // Luckily enough, C allows us to "switch" on uint8s, since characters are also numbers via the
  82:.\uart_helper_fcns.c ****     switch( received_byte )
  62              		.loc 1 82 0
  63 000e FB79     		ldrb	r3, [r7, #7]	@ zero_extendqisi2
  64 0010 0D2B     		cmp	r3, #13
  65 0012 09D0     		beq	.L3
  66 0014 0D2B     		cmp	r3, #13
  67 0016 02DC     		bgt	.L4
  68 0018 0A2B     		cmp	r3, #10
  69 001a 05D0     		beq	.L3
  70 001c 1EE0     		b	.L2
  71              	.L4:
  72 001e 652B     		cmp	r3, #101
  73 0020 13D0     		beq	.L5
  74 0022 782B     		cmp	r3, #120
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 4


  75 0024 08D0     		beq	.L6
  76 0026 19E0     		b	.L2
  77              	.L3:
  83:.\uart_helper_fcns.c ****     {
  84:.\uart_helper_fcns.c ****         // Students: look up switch-case statements. to understand this more.
  85:.\uart_helper_fcns.c ****         // We're going to take advantage of the "flow" of switch-case to do the same thing for char
  86:.\uart_helper_fcns.c ****         // which could all be newlines, by not "break"-ing until the end of the third case.
  87:.\uart_helper_fcns.c ****         case '\r':
  88:.\uart_helper_fcns.c ****             // flow downward, no specific code for carriage return
  89:.\uart_helper_fcns.c ****         case '\n':
  90:.\uart_helper_fcns.c ****             // This code will run if the received byte is either a carriage return or a newline.
  91:.\uart_helper_fcns.c ****             // Since the PSoC received a new line...
  92:.\uart_helper_fcns.c ****             // First, terminate the string. This is for the use of sscanf below.
  93:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = '\0';
  78              		.loc 1 93 0
  79 0028 144B     		ldr	r3, .L8
  80 002a 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
  81 002c 144A     		ldr	r2, .L8+4
  82 002e 0021     		movs	r1, #0
  83 0030 D154     		strb	r1, [r2, r3]
  94:.\uart_helper_fcns.c ****             Write_PWM_and_UART();
  84              		.loc 1 94 0
  85 0032 FFF7FEFF 		bl	Write_PWM_and_UART
  95:.\uart_helper_fcns.c ****             // This helper will also reset the period we're tracking, and the num chars received.
  96:.\uart_helper_fcns.c ****             // By "break"-ing, the next case is not executed.
  97:.\uart_helper_fcns.c ****             break;
  86              		.loc 1 97 0
  87 0036 1DE0     		b	.L1
  88              	.L6:
  98:.\uart_helper_fcns.c ****         case 'x':
  99:.\uart_helper_fcns.c ****             // Added functionality: if the user types an x, then the PWM stops.
 100:.\uart_helper_fcns.c ****             UART_for_USB_PutString("Stopping PWM.\r\n");
  89              		.loc 1 100 0
  90 0038 1248     		ldr	r0, .L8+8
  91 003a FFF7FEFF 		bl	UART_for_USB_PutString
 101:.\uart_helper_fcns.c ****             PWM_Servo_Stop();
  92              		.loc 1 101 0
  93 003e FFF7FEFF 		bl	PWM_Servo_Stop
 102:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
 103:.\uart_helper_fcns.c ****             num_chars_received = 0;
  94              		.loc 1 103 0
  95 0042 0E4B     		ldr	r3, .L8
  96 0044 0022     		movs	r2, #0
  97 0046 1A70     		strb	r2, [r3]
 104:.\uart_helper_fcns.c ****             break;
  98              		.loc 1 104 0
  99 0048 14E0     		b	.L1
 100              	.L5:
 105:.\uart_helper_fcns.c ****         case 'e':
 106:.\uart_helper_fcns.c ****             // Similarly, type e to enable.
 107:.\uart_helper_fcns.c ****             UART_for_USB_PutString("Restarting PWM.\r\n");
 101              		.loc 1 107 0
 102 004a 0F48     		ldr	r0, .L8+12
 103 004c FFF7FEFF 		bl	UART_for_USB_PutString
 108:.\uart_helper_fcns.c ****             PWM_Servo_Start();
 104              		.loc 1 108 0
 105 0050 FFF7FEFF 		bl	PWM_Servo_Start
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 5


 109:.\uart_helper_fcns.c ****             // Reset the buffer. We'll just start writing from the start again.
 110:.\uart_helper_fcns.c ****             num_chars_received = 0;
 106              		.loc 1 110 0
 107 0054 094B     		ldr	r3, .L8
 108 0056 0022     		movs	r2, #0
 109 0058 1A70     		strb	r2, [r3]
 111:.\uart_helper_fcns.c ****             break;
 110              		.loc 1 111 0
 111 005a 0BE0     		b	.L1
 112              	.L2:
 112:.\uart_helper_fcns.c ****         default:
 113:.\uart_helper_fcns.c ****             // The "default" case is "anything else", which is "store another character."
 114:.\uart_helper_fcns.c ****             // Add to the received buffer.
 115:.\uart_helper_fcns.c ****             receive_buffer[num_chars_received] = received_byte;
 113              		.loc 1 115 0
 114 005c 074B     		ldr	r3, .L8
 115 005e 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 116 0060 074A     		ldr	r2, .L8+4
 117 0062 F979     		ldrb	r1, [r7, #7]
 118 0064 D154     		strb	r1, [r2, r3]
 116:.\uart_helper_fcns.c ****             // We need to increment the counter. i++ does this without an equals sign for assignmen
 117:.\uart_helper_fcns.c ****             num_chars_received++;
 119              		.loc 1 117 0
 120 0066 054B     		ldr	r3, .L8
 121 0068 1B78     		ldrb	r3, [r3]	@ zero_extendqisi2
 122 006a 0133     		adds	r3, r3, #1
 123 006c DAB2     		uxtb	r2, r3
 124 006e 034B     		ldr	r3, .L8
 125 0070 1A70     		strb	r2, [r3]
 118:.\uart_helper_fcns.c ****             break;
 126              		.loc 1 118 0
 127 0072 00BF     		nop
 128              	.L1:
 119:.\uart_helper_fcns.c ****         // end of case statement.
 120:.\uart_helper_fcns.c ****     }
 121:.\uart_helper_fcns.c ****     
 122:.\uart_helper_fcns.c ****     // We're going to assume that the character we receive is an integer, 
 123:.\uart_helper_fcns.c ****     // representing the period.
 124:.\uart_helper_fcns.c ****     // For a transmission of 8 bits, we can only set the period between 0 and 255.
 125:.\uart_helper_fcns.c ****     // This is OK for how we've configured the PWM for our servo: 
 126:.\uart_helper_fcns.c ****     // our period can only be between 100 and 200 anyway (1 ms for min angle, 2 ms for max angle).
 127:.\uart_helper_fcns.c ****     // To get better resolution here, you'll need to do a handful of things:
 128:.\uart_helper_fcns.c ****     // (1) change the clock of the PWM so that we'll need a uint16 to represent 1 ms to 2 ms of "on
 129:.\uart_helper_fcns.c ****     // (2) receive two bytes (as uint8) from the UART, keep track of the first one
 130:.\uart_helper_fcns.c ****     // (3) once two are received, combine them into a uint16
 131:.\uart_helper_fcns.c ****     // (4) write the uint16 to the PWM's period, as with the code below.    
 132:.\uart_helper_fcns.c ****     
 133:.\uart_helper_fcns.c ****     
 134:.\uart_helper_fcns.c ****     
 135:.\uart_helper_fcns.c **** }
 129              		.loc 1 135 0
 130 0074 0837     		adds	r7, r7, #8
 131 0076 BD46     		mov	sp, r7
 132              		@ sp needed
 133 0078 80BD     		pop	{r7, pc}
 134              	.L9:
 135 007a 00BF     		.align	2
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 6


 136              	.L8:
 137 007c 00010000 		.word	num_chars_received
 138 0080 80000000 		.word	receive_buffer
 139 0084 00000000 		.word	.LC0
 140 0088 10000000 		.word	.LC1
 141              		.cfi_endproc
 142              	.LFE56:
 143              		.size	Interrupt_Handler_UART_Receive, .-Interrupt_Handler_UART_Receive
 144              		.section	.rodata
 145 0022 0000     		.align	2
 146              	.LC2:
 147 0024 703A2568 		.ascii	"p:%hu\000"
 147      7500
 148 002a 0000     		.align	2
 149              	.LC3:
 150 002c 52656365 		.ascii	"Received the string: \000"
 150      69766564 
 150      20746865 
 150      20737472 
 150      696E673A 
 151 0042 0000     		.align	2
 152              	.LC4:
 153 0044 0D0A00   		.ascii	"\015\012\000"
 154 0047 00       		.align	2
 155              	.LC5:
 156 0048 50574D20 		.ascii	"PWM now has a period of: %i \015\012\000"
 156      6E6F7720 
 156      68617320 
 156      61207065 
 156      72696F64 
 157 0067 00       		.align	2
 158              	.LC6:
 159 0068 53657420 		.ascii	"Set the period by typing p: then a new period, betw"
 159      74686520 
 159      70657269 
 159      6F642062 
 159      79207479 
 160 009b 65656E20 		.ascii	"een 100 and 200 (min and max period for a servo on "
 160      31303020 
 160      616E6420 
 160      32303020 
 160      286D696E 
 161 00ce 61203130 		.ascii	"a 100 kHz clock).\015\012\000"
 161      30206B48 
 161      7A20636C 
 161      6F636B29 
 161      2E0D0A00 
 162 00e2 0000     		.section	.text.Write_PWM_and_UART,"ax",%progbits
 163              		.align	2
 164              		.global	Write_PWM_and_UART
 165              		.thumb
 166              		.thumb_func
 167              		.type	Write_PWM_and_UART, %function
 168              	Write_PWM_and_UART:
 169              	.LFB57:
 136:.\uart_helper_fcns.c **** 
 137:.\uart_helper_fcns.c **** // Helper function that does the writing to the PWM and UART.
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 7


 138:.\uart_helper_fcns.c **** // makes the ISR code easier to understand.
 139:.\uart_helper_fcns.c **** void Write_PWM_and_UART(){
 170              		.loc 1 139 0
 171              		.cfi_startproc
 172              		@ args = 0, pretend = 0, frame = 8
 173              		@ frame_needed = 1, uses_anonymous_args = 0
 174 0000 80B5     		push	{r7, lr}
 175              		.cfi_def_cfa_offset 8
 176              		.cfi_offset 7, -8
 177              		.cfi_offset 14, -4
 178 0002 82B0     		sub	sp, sp, #8
 179              		.cfi_def_cfa_offset 16
 180 0004 00AF     		add	r7, sp, #0
 181              		.cfi_def_cfa_register 7
 140:.\uart_helper_fcns.c ****     // OK, so now, we have a string in the receive buffer of the form "p:somenumber".
 141:.\uart_helper_fcns.c ****     
 142:.\uart_helper_fcns.c ****     // Read in the integer after the p:
 143:.\uart_helper_fcns.c ****     sscanf( receive_buffer, "p:%hu", &period);
 182              		.loc 1 143 0
 183 0006 1648     		ldr	r0, .L11
 184 0008 1649     		ldr	r1, .L11+4
 185 000a 174A     		ldr	r2, .L11+8
 186 000c FFF7FEFF 		bl	sscanf
 144:.\uart_helper_fcns.c ****     // DEBUGGING
 145:.\uart_helper_fcns.c ****     UART_for_USB_PutString("Received the string: ");
 187              		.loc 1 145 0
 188 0010 1648     		ldr	r0, .L11+12
 189 0012 FFF7FEFF 		bl	UART_for_USB_PutString
 146:.\uart_helper_fcns.c ****     UART_for_USB_PutString( receive_buffer );
 190              		.loc 1 146 0
 191 0016 1248     		ldr	r0, .L11
 192 0018 FFF7FEFF 		bl	UART_for_USB_PutString
 147:.\uart_helper_fcns.c ****     UART_for_USB_PutString("\r\n");
 193              		.loc 1 147 0
 194 001c 1448     		ldr	r0, .L11+16
 195 001e FFF7FEFF 		bl	UART_for_USB_PutString
 148:.\uart_helper_fcns.c ****     
 149:.\uart_helper_fcns.c ****     // TO-DO: checking on output of sscanf to confirm the user wrote a p:
 150:.\uart_helper_fcns.c ****     // sscanf requires the address-of (&) for the variable to be written.
 151:.\uart_helper_fcns.c ****     // Now, set the period, 
 152:.\uart_helper_fcns.c ****     PWM_Servo_WritePeriod( period );
 196              		.loc 1 152 0
 197 0022 114B     		ldr	r3, .L11+8
 198 0024 1B88     		ldrh	r3, [r3]
 199 0026 1846     		mov	r0, r3
 200 0028 FFF7FEFF 		bl	PWM_Servo_WritePeriod
 153:.\uart_helper_fcns.c ****     
 154:.\uart_helper_fcns.c ****     // and send back the period that was just written, for confirmation.
 155:.\uart_helper_fcns.c ****     // In C, to concatenate a number (integer) and a string (characters), you need to...
 156:.\uart_helper_fcns.c ****     // (1) store the result, as confirmed by the PWM component.
 157:.\uart_helper_fcns.c ****     uint16 period_written = PWM_Servo_ReadPeriod();
 201              		.loc 1 157 0
 202 002c FFF7FEFF 		bl	PWM_Servo_ReadPeriod
 203 0030 0346     		mov	r3, r0
 204 0032 FB80     		strh	r3, [r7, #6]	@ movhi
 158:.\uart_helper_fcns.c ****     // (2) Concatenate this period with a string of characters describing what we did
 159:.\uart_helper_fcns.c ****     // Requires stdio.h (standard input/output) for the sprintf function.
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 8


 160:.\uart_helper_fcns.c ****     sprintf( transmit_buffer, "PWM now has a period of: %i \r\n", period_written);
 205              		.loc 1 160 0
 206 0034 FB88     		ldrh	r3, [r7, #6]
 207 0036 0F48     		ldr	r0, .L11+20
 208 0038 0F49     		ldr	r1, .L11+24
 209 003a 1A46     		mov	r2, r3
 210 003c FFF7FEFF 		bl	sprintf
 161:.\uart_helper_fcns.c ****     // (3) send the byte back to your PC
 162:.\uart_helper_fcns.c ****     UART_for_USB_PutString( transmit_buffer );    
 211              		.loc 1 162 0
 212 0040 0C48     		ldr	r0, .L11+20
 213 0042 FFF7FEFF 		bl	UART_for_USB_PutString
 163:.\uart_helper_fcns.c ****     // (4) Send another little string prompting the next input.
 164:.\uart_helper_fcns.c ****     UART_for_USB_PutString( "Set the period by typing p: then a new period, between 100 and 200 (mi
 214              		.loc 1 164 0
 215 0046 0D48     		ldr	r0, .L11+28
 216 0048 FFF7FEFF 		bl	UART_for_USB_PutString
 165:.\uart_helper_fcns.c ****     // Reset the indexing into the array
 166:.\uart_helper_fcns.c ****     num_chars_received = 0;
 217              		.loc 1 166 0
 218 004c 0C4B     		ldr	r3, .L11+32
 219 004e 0022     		movs	r2, #0
 220 0050 1A70     		strb	r2, [r3]
 167:.\uart_helper_fcns.c ****     // and just in case let's do the period too.
 168:.\uart_helper_fcns.c ****     period = 0;
 221              		.loc 1 168 0
 222 0052 054B     		ldr	r3, .L11+8
 223 0054 0022     		movs	r2, #0
 224 0056 1A80     		strh	r2, [r3]	@ movhi
 169:.\uart_helper_fcns.c ****     // Note that we don't have to reset the buffer here, since sscanf only reads up until the first
 170:.\uart_helper_fcns.c **** }
 225              		.loc 1 170 0
 226 0058 0837     		adds	r7, r7, #8
 227 005a BD46     		mov	sp, r7
 228              		@ sp needed
 229 005c 80BD     		pop	{r7, pc}
 230              	.L12:
 231 005e 00BF     		.align	2
 232              	.L11:
 233 0060 80000000 		.word	receive_buffer
 234 0064 24000000 		.word	.LC2
 235 0068 02010000 		.word	period
 236 006c 2C000000 		.word	.LC3
 237 0070 44000000 		.word	.LC4
 238 0074 00000000 		.word	transmit_buffer
 239 0078 48000000 		.word	.LC5
 240 007c 68000000 		.word	.LC6
 241 0080 00010000 		.word	num_chars_received
 242              		.cfi_endproc
 243              	.LFE57:
 244              		.size	Write_PWM_and_UART, .-Write_PWM_and_UART
 245              		.text
 246              	.Letext0:
 247              		.file 2 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
 248              		.file 3 "c:\\program files (x86)\\cypress\\psoc creator\\3.1\\psoc creator\\import\\gnu_cs\\arm\\4
 249              		.file 4 ".\\Generated_Source\\PSoC5/cytypes.h"
 250              		.file 5 ".\\Generated_Source\\PSoC5/core_cm3.h"
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 9


 251              		.section	.debug_info,"",%progbits
 252              	.Ldebug_info0:
 253 0000 5D010000 		.4byte	0x15d
 254 0004 0400     		.2byte	0x4
 255 0006 00000000 		.4byte	.Ldebug_abbrev0
 256 000a 04       		.byte	0x4
 257 000b 01       		.uleb128 0x1
 258 000c 35010000 		.4byte	.LASF23
 259 0010 01       		.byte	0x1
 260 0011 10020000 		.4byte	.LASF24
 261 0015 6C000000 		.4byte	.LASF25
 262 0019 00000000 		.4byte	.Ldebug_ranges0+0
 263 001d 00000000 		.4byte	0
 264 0021 00000000 		.4byte	.Ldebug_line0
 265 0025 02       		.uleb128 0x2
 266 0026 01       		.byte	0x1
 267 0027 06       		.byte	0x6
 268 0028 29010000 		.4byte	.LASF0
 269 002c 02       		.uleb128 0x2
 270 002d 01       		.byte	0x1
 271 002e 08       		.byte	0x8
 272 002f BD000000 		.4byte	.LASF1
 273 0033 02       		.uleb128 0x2
 274 0034 02       		.byte	0x2
 275 0035 05       		.byte	0x5
 276 0036 C1010000 		.4byte	.LASF2
 277 003a 02       		.uleb128 0x2
 278 003b 02       		.byte	0x2
 279 003c 07       		.byte	0x7
 280 003d 0E000000 		.4byte	.LASF3
 281 0041 03       		.uleb128 0x3
 282 0042 B1010000 		.4byte	.LASF9
 283 0046 02       		.byte	0x2
 284 0047 37       		.byte	0x37
 285 0048 4C000000 		.4byte	0x4c
 286 004c 02       		.uleb128 0x2
 287 004d 04       		.byte	0x4
 288 004e 05       		.byte	0x5
 289 004f E3000000 		.4byte	.LASF4
 290 0053 02       		.uleb128 0x2
 291 0054 04       		.byte	0x4
 292 0055 07       		.byte	0x7
 293 0056 43000000 		.4byte	.LASF5
 294 005a 02       		.uleb128 0x2
 295 005b 08       		.byte	0x8
 296 005c 05       		.byte	0x5
 297 005d 00000000 		.4byte	.LASF6
 298 0061 02       		.uleb128 0x2
 299 0062 08       		.byte	0x8
 300 0063 07       		.byte	0x7
 301 0064 55000000 		.4byte	.LASF7
 302 0068 04       		.uleb128 0x4
 303 0069 04       		.byte	0x4
 304 006a 05       		.byte	0x5
 305 006b 696E7400 		.ascii	"int\000"
 306 006f 02       		.uleb128 0x2
 307 0070 04       		.byte	0x4
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 10


 308 0071 07       		.byte	0x7
 309 0072 21000000 		.4byte	.LASF8
 310 0076 03       		.uleb128 0x3
 311 0077 EC000000 		.4byte	.LASF10
 312 007b 03       		.byte	0x3
 313 007c 41       		.byte	0x41
 314 007d 41000000 		.4byte	0x41
 315 0081 03       		.uleb128 0x3
 316 0082 2E000000 		.4byte	.LASF11
 317 0086 04       		.byte	0x4
 318 0087 A1       		.byte	0xa1
 319 0088 2C000000 		.4byte	0x2c
 320 008c 03       		.uleb128 0x3
 321 008d CB010000 		.4byte	.LASF12
 322 0091 04       		.byte	0x4
 323 0092 A2       		.byte	0xa2
 324 0093 3A000000 		.4byte	0x3a
 325 0097 02       		.uleb128 0x2
 326 0098 04       		.byte	0x4
 327 0099 04       		.byte	0x4
 328 009a BB010000 		.4byte	.LASF13
 329 009e 02       		.uleb128 0x2
 330 009f 08       		.byte	0x8
 331 00a0 04       		.byte	0x4
 332 00a1 07010000 		.4byte	.LASF14
 333 00a5 02       		.uleb128 0x2
 334 00a6 01       		.byte	0x1
 335 00a7 08       		.byte	0x8
 336 00a8 CB000000 		.4byte	.LASF15
 337 00ac 02       		.uleb128 0x2
 338 00ad 04       		.byte	0x4
 339 00ae 07       		.byte	0x7
 340 00af 07020000 		.4byte	.LASF16
 341 00b3 05       		.uleb128 0x5
 342 00b4 D2010000 		.4byte	.LASF26
 343 00b8 01       		.byte	0x1
 344 00b9 41       		.byte	0x41
 345 00ba 00000000 		.4byte	.LFB56
 346 00be 8C000000 		.4byte	.LFE56-.LFB56
 347 00c2 01       		.uleb128 0x1
 348 00c3 9C       		.byte	0x9c
 349 00c4 D7000000 		.4byte	0xd7
 350 00c8 06       		.uleb128 0x6
 351 00c9 0E010000 		.4byte	.LASF17
 352 00cd 01       		.byte	0x1
 353 00ce 44       		.byte	0x44
 354 00cf 81000000 		.4byte	0x81
 355 00d3 02       		.uleb128 0x2
 356 00d4 91       		.byte	0x91
 357 00d5 77       		.sleb128 -9
 358 00d6 00       		.byte	0
 359 00d7 07       		.uleb128 0x7
 360 00d8 F4000000 		.4byte	.LASF27
 361 00dc 01       		.byte	0x1
 362 00dd 8B       		.byte	0x8b
 363 00de 00000000 		.4byte	.LFB57
 364 00e2 84000000 		.4byte	.LFE57-.LFB57
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 11


 365 00e6 01       		.uleb128 0x1
 366 00e7 9C       		.byte	0x9c
 367 00e8 FB000000 		.4byte	0xfb
 368 00ec 06       		.uleb128 0x6
 369 00ed F8010000 		.4byte	.LASF18
 370 00f1 01       		.byte	0x1
 371 00f2 9D       		.byte	0x9d
 372 00f3 8C000000 		.4byte	0x8c
 373 00f7 02       		.uleb128 0x2
 374 00f8 91       		.byte	0x91
 375 00f9 76       		.sleb128 -10
 376 00fa 00       		.byte	0
 377 00fb 08       		.uleb128 0x8
 378 00fc A5000000 		.4byte	0xa5
 379 0100 0B010000 		.4byte	0x10b
 380 0104 09       		.uleb128 0x9
 381 0105 AC000000 		.4byte	0xac
 382 0109 7F       		.byte	0x7f
 383 010a 00       		.byte	0
 384 010b 06       		.uleb128 0x6
 385 010c AD000000 		.4byte	.LASF19
 386 0110 01       		.byte	0x1
 387 0111 2B       		.byte	0x2b
 388 0112 FB000000 		.4byte	0xfb
 389 0116 05       		.uleb128 0x5
 390 0117 03       		.byte	0x3
 391 0118 00000000 		.4byte	transmit_buffer
 392 011c 06       		.uleb128 0x6
 393 011d 34000000 		.4byte	.LASF20
 394 0121 01       		.byte	0x1
 395 0122 2D       		.byte	0x2d
 396 0123 FB000000 		.4byte	0xfb
 397 0127 05       		.uleb128 0x5
 398 0128 03       		.byte	0x3
 399 0129 80000000 		.4byte	receive_buffer
 400 012d 06       		.uleb128 0x6
 401 012e D0000000 		.4byte	.LASF21
 402 0132 01       		.byte	0x1
 403 0133 36       		.byte	0x36
 404 0134 81000000 		.4byte	0x81
 405 0138 05       		.uleb128 0x5
 406 0139 03       		.byte	0x3
 407 013a 00010000 		.4byte	num_chars_received
 408 013e 06       		.uleb128 0x6
 409 013f F1010000 		.4byte	.LASF22
 410 0143 01       		.byte	0x1
 411 0144 3C       		.byte	0x3c
 412 0145 8C000000 		.4byte	0x8c
 413 0149 05       		.uleb128 0x5
 414 014a 03       		.byte	0x3
 415 014b 02010000 		.4byte	period
 416 014f 0A       		.uleb128 0xa
 417 0150 1C010000 		.4byte	.LASF28
 418 0154 05       		.byte	0x5
 419 0155 1606     		.2byte	0x616
 420 0157 5B010000 		.4byte	0x15b
 421 015b 0B       		.uleb128 0xb
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 12


 422 015c 76000000 		.4byte	0x76
 423 0160 00       		.byte	0
 424              		.section	.debug_abbrev,"",%progbits
 425              	.Ldebug_abbrev0:
 426 0000 01       		.uleb128 0x1
 427 0001 11       		.uleb128 0x11
 428 0002 01       		.byte	0x1
 429 0003 25       		.uleb128 0x25
 430 0004 0E       		.uleb128 0xe
 431 0005 13       		.uleb128 0x13
 432 0006 0B       		.uleb128 0xb
 433 0007 03       		.uleb128 0x3
 434 0008 0E       		.uleb128 0xe
 435 0009 1B       		.uleb128 0x1b
 436 000a 0E       		.uleb128 0xe
 437 000b 55       		.uleb128 0x55
 438 000c 17       		.uleb128 0x17
 439 000d 11       		.uleb128 0x11
 440 000e 01       		.uleb128 0x1
 441 000f 10       		.uleb128 0x10
 442 0010 17       		.uleb128 0x17
 443 0011 00       		.byte	0
 444 0012 00       		.byte	0
 445 0013 02       		.uleb128 0x2
 446 0014 24       		.uleb128 0x24
 447 0015 00       		.byte	0
 448 0016 0B       		.uleb128 0xb
 449 0017 0B       		.uleb128 0xb
 450 0018 3E       		.uleb128 0x3e
 451 0019 0B       		.uleb128 0xb
 452 001a 03       		.uleb128 0x3
 453 001b 0E       		.uleb128 0xe
 454 001c 00       		.byte	0
 455 001d 00       		.byte	0
 456 001e 03       		.uleb128 0x3
 457 001f 16       		.uleb128 0x16
 458 0020 00       		.byte	0
 459 0021 03       		.uleb128 0x3
 460 0022 0E       		.uleb128 0xe
 461 0023 3A       		.uleb128 0x3a
 462 0024 0B       		.uleb128 0xb
 463 0025 3B       		.uleb128 0x3b
 464 0026 0B       		.uleb128 0xb
 465 0027 49       		.uleb128 0x49
 466 0028 13       		.uleb128 0x13
 467 0029 00       		.byte	0
 468 002a 00       		.byte	0
 469 002b 04       		.uleb128 0x4
 470 002c 24       		.uleb128 0x24
 471 002d 00       		.byte	0
 472 002e 0B       		.uleb128 0xb
 473 002f 0B       		.uleb128 0xb
 474 0030 3E       		.uleb128 0x3e
 475 0031 0B       		.uleb128 0xb
 476 0032 03       		.uleb128 0x3
 477 0033 08       		.uleb128 0x8
 478 0034 00       		.byte	0
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 13


 479 0035 00       		.byte	0
 480 0036 05       		.uleb128 0x5
 481 0037 2E       		.uleb128 0x2e
 482 0038 01       		.byte	0x1
 483 0039 3F       		.uleb128 0x3f
 484 003a 19       		.uleb128 0x19
 485 003b 03       		.uleb128 0x3
 486 003c 0E       		.uleb128 0xe
 487 003d 3A       		.uleb128 0x3a
 488 003e 0B       		.uleb128 0xb
 489 003f 3B       		.uleb128 0x3b
 490 0040 0B       		.uleb128 0xb
 491 0041 27       		.uleb128 0x27
 492 0042 19       		.uleb128 0x19
 493 0043 11       		.uleb128 0x11
 494 0044 01       		.uleb128 0x1
 495 0045 12       		.uleb128 0x12
 496 0046 06       		.uleb128 0x6
 497 0047 40       		.uleb128 0x40
 498 0048 18       		.uleb128 0x18
 499 0049 9642     		.uleb128 0x2116
 500 004b 19       		.uleb128 0x19
 501 004c 01       		.uleb128 0x1
 502 004d 13       		.uleb128 0x13
 503 004e 00       		.byte	0
 504 004f 00       		.byte	0
 505 0050 06       		.uleb128 0x6
 506 0051 34       		.uleb128 0x34
 507 0052 00       		.byte	0
 508 0053 03       		.uleb128 0x3
 509 0054 0E       		.uleb128 0xe
 510 0055 3A       		.uleb128 0x3a
 511 0056 0B       		.uleb128 0xb
 512 0057 3B       		.uleb128 0x3b
 513 0058 0B       		.uleb128 0xb
 514 0059 49       		.uleb128 0x49
 515 005a 13       		.uleb128 0x13
 516 005b 02       		.uleb128 0x2
 517 005c 18       		.uleb128 0x18
 518 005d 00       		.byte	0
 519 005e 00       		.byte	0
 520 005f 07       		.uleb128 0x7
 521 0060 2E       		.uleb128 0x2e
 522 0061 01       		.byte	0x1
 523 0062 3F       		.uleb128 0x3f
 524 0063 19       		.uleb128 0x19
 525 0064 03       		.uleb128 0x3
 526 0065 0E       		.uleb128 0xe
 527 0066 3A       		.uleb128 0x3a
 528 0067 0B       		.uleb128 0xb
 529 0068 3B       		.uleb128 0x3b
 530 0069 0B       		.uleb128 0xb
 531 006a 11       		.uleb128 0x11
 532 006b 01       		.uleb128 0x1
 533 006c 12       		.uleb128 0x12
 534 006d 06       		.uleb128 0x6
 535 006e 40       		.uleb128 0x40
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 14


 536 006f 18       		.uleb128 0x18
 537 0070 9642     		.uleb128 0x2116
 538 0072 19       		.uleb128 0x19
 539 0073 01       		.uleb128 0x1
 540 0074 13       		.uleb128 0x13
 541 0075 00       		.byte	0
 542 0076 00       		.byte	0
 543 0077 08       		.uleb128 0x8
 544 0078 01       		.uleb128 0x1
 545 0079 01       		.byte	0x1
 546 007a 49       		.uleb128 0x49
 547 007b 13       		.uleb128 0x13
 548 007c 01       		.uleb128 0x1
 549 007d 13       		.uleb128 0x13
 550 007e 00       		.byte	0
 551 007f 00       		.byte	0
 552 0080 09       		.uleb128 0x9
 553 0081 21       		.uleb128 0x21
 554 0082 00       		.byte	0
 555 0083 49       		.uleb128 0x49
 556 0084 13       		.uleb128 0x13
 557 0085 2F       		.uleb128 0x2f
 558 0086 0B       		.uleb128 0xb
 559 0087 00       		.byte	0
 560 0088 00       		.byte	0
 561 0089 0A       		.uleb128 0xa
 562 008a 34       		.uleb128 0x34
 563 008b 00       		.byte	0
 564 008c 03       		.uleb128 0x3
 565 008d 0E       		.uleb128 0xe
 566 008e 3A       		.uleb128 0x3a
 567 008f 0B       		.uleb128 0xb
 568 0090 3B       		.uleb128 0x3b
 569 0091 05       		.uleb128 0x5
 570 0092 49       		.uleb128 0x49
 571 0093 13       		.uleb128 0x13
 572 0094 3F       		.uleb128 0x3f
 573 0095 19       		.uleb128 0x19
 574 0096 3C       		.uleb128 0x3c
 575 0097 19       		.uleb128 0x19
 576 0098 00       		.byte	0
 577 0099 00       		.byte	0
 578 009a 0B       		.uleb128 0xb
 579 009b 35       		.uleb128 0x35
 580 009c 00       		.byte	0
 581 009d 49       		.uleb128 0x49
 582 009e 13       		.uleb128 0x13
 583 009f 00       		.byte	0
 584 00a0 00       		.byte	0
 585 00a1 00       		.byte	0
 586              		.section	.debug_aranges,"",%progbits
 587 0000 24000000 		.4byte	0x24
 588 0004 0200     		.2byte	0x2
 589 0006 00000000 		.4byte	.Ldebug_info0
 590 000a 04       		.byte	0x4
 591 000b 00       		.byte	0
 592 000c 0000     		.2byte	0
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 15


 593 000e 0000     		.2byte	0
 594 0010 00000000 		.4byte	.LFB56
 595 0014 8C000000 		.4byte	.LFE56-.LFB56
 596 0018 00000000 		.4byte	.LFB57
 597 001c 84000000 		.4byte	.LFE57-.LFB57
 598 0020 00000000 		.4byte	0
 599 0024 00000000 		.4byte	0
 600              		.section	.debug_ranges,"",%progbits
 601              	.Ldebug_ranges0:
 602 0000 00000000 		.4byte	.LFB56
 603 0004 8C000000 		.4byte	.LFE56
 604 0008 00000000 		.4byte	.LFB57
 605 000c 84000000 		.4byte	.LFE57
 606 0010 00000000 		.4byte	0
 607 0014 00000000 		.4byte	0
 608              		.section	.debug_line,"",%progbits
 609              	.Ldebug_line0:
 610 0000 A6010000 		.section	.debug_str,"MS",%progbits,1
 610      02005D01 
 610      00000201 
 610      FB0E0D00 
 610      01010101 
 611              	.LASF6:
 612 0000 6C6F6E67 		.ascii	"long long int\000"
 612      206C6F6E 
 612      6720696E 
 612      7400
 613              	.LASF3:
 614 000e 73686F72 		.ascii	"short unsigned int\000"
 614      7420756E 
 614      7369676E 
 614      65642069 
 614      6E7400
 615              	.LASF8:
 616 0021 756E7369 		.ascii	"unsigned int\000"
 616      676E6564 
 616      20696E74 
 616      00
 617              	.LASF11:
 618 002e 75696E74 		.ascii	"uint8\000"
 618      3800
 619              	.LASF20:
 620 0034 72656365 		.ascii	"receive_buffer\000"
 620      6976655F 
 620      62756666 
 620      657200
 621              	.LASF5:
 622 0043 6C6F6E67 		.ascii	"long unsigned int\000"
 622      20756E73 
 622      69676E65 
 622      6420696E 
 622      7400
 623              	.LASF7:
 624 0055 6C6F6E67 		.ascii	"long long unsigned int\000"
 624      206C6F6E 
 624      6720756E 
 624      7369676E 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 16


 624      65642069 
 625              	.LASF25:
 626 006c 443A5C57 		.ascii	"D:\\WindowsGitHub\\psoc-examples\\me235\\PWM_UART_M"
 626      696E646F 
 626      77734769 
 626      74487562 
 626      5C70736F 
 627 009b 756C7469 		.ascii	"ultitasking.cydsn\000"
 627      7461736B 
 627      696E672E 
 627      63796473 
 627      6E00
 628              	.LASF19:
 629 00ad 7472616E 		.ascii	"transmit_buffer\000"
 629      736D6974 
 629      5F627566 
 629      66657200 
 630              	.LASF1:
 631 00bd 756E7369 		.ascii	"unsigned char\000"
 631      676E6564 
 631      20636861 
 631      7200
 632              	.LASF15:
 633 00cb 63686172 		.ascii	"char\000"
 633      00
 634              	.LASF21:
 635 00d0 6E756D5F 		.ascii	"num_chars_received\000"
 635      63686172 
 635      735F7265 
 635      63656976 
 635      656400
 636              	.LASF4:
 637 00e3 6C6F6E67 		.ascii	"long int\000"
 637      20696E74 
 637      00
 638              	.LASF10:
 639 00ec 696E7433 		.ascii	"int32_t\000"
 639      325F7400 
 640              	.LASF27:
 641 00f4 57726974 		.ascii	"Write_PWM_and_UART\000"
 641      655F5057 
 641      4D5F616E 
 641      645F5541 
 641      525400
 642              	.LASF14:
 643 0107 646F7562 		.ascii	"double\000"
 643      6C6500
 644              	.LASF17:
 645 010e 72656365 		.ascii	"received_byte\000"
 645      69766564 
 645      5F627974 
 645      6500
 646              	.LASF28:
 647 011c 49544D5F 		.ascii	"ITM_RxBuffer\000"
 647      52784275 
 647      66666572 
 647      00
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 17


 648              	.LASF0:
 649 0129 7369676E 		.ascii	"signed char\000"
 649      65642063 
 649      68617200 
 650              	.LASF23:
 651 0135 474E5520 		.ascii	"GNU C 4.8.4 20140526 (release) [ARM/embedded-4_8-br"
 651      4320342E 
 651      382E3420 
 651      32303134 
 651      30353236 
 652 0168 616E6368 		.ascii	"anch revision 211358] -mcpu=cortex-m3 -mthumb -g -O"
 652      20726576 
 652      6973696F 
 652      6E203231 
 652      31333538 
 653 019b 30202D66 		.ascii	"0 -ffunction-sections\000"
 653      66756E63 
 653      74696F6E 
 653      2D736563 
 653      74696F6E 
 654              	.LASF9:
 655 01b1 5F5F696E 		.ascii	"__int32_t\000"
 655      7433325F 
 655      7400
 656              	.LASF13:
 657 01bb 666C6F61 		.ascii	"float\000"
 657      7400
 658              	.LASF2:
 659 01c1 73686F72 		.ascii	"short int\000"
 659      7420696E 
 659      7400
 660              	.LASF12:
 661 01cb 75696E74 		.ascii	"uint16\000"
 661      313600
 662              	.LASF26:
 663 01d2 496E7465 		.ascii	"Interrupt_Handler_UART_Receive\000"
 663      72727570 
 663      745F4861 
 663      6E646C65 
 663      725F5541 
 664              	.LASF22:
 665 01f1 70657269 		.ascii	"period\000"
 665      6F6400
 666              	.LASF18:
 667 01f8 70657269 		.ascii	"period_written\000"
 667      6F645F77 
 667      72697474 
 667      656E00
 668              	.LASF16:
 669 0207 73697A65 		.ascii	"sizetype\000"
 669      74797065 
 669      00
 670              	.LASF24:
 671 0210 2E5C7561 		.ascii	".\\uart_helper_fcns.c\000"
 671      72745F68 
 671      656C7065 
 671      725F6663 
ARM GAS  C:\Users\andre\AppData\Local\Temp\ccI9Ha1w.s 			page 18


 671      6E732E63 
 672              		.ident	"GCC: (GNU Tools for ARM Embedded Processors) 4.8.4 20140526 (release) [ARM/embedded-4_8-br
